<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>前端面试</title>
    <url>/2022/11/08/fe-interview/</url>
    <content><![CDATA[<h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><h3 id="this-的指向（谁调用指向谁）"><a href="#this-的指向（谁调用指向谁）" class="headerlink" title="this 的指向（谁调用指向谁）"></a>this 的指向（谁调用指向谁）</h3><h3 id="普通函数和箭头函数的区别"><a href="#普通函数和箭头函数的区别" class="headerlink" title="普通函数和箭头函数的区别"></a>普通函数和箭头函数的区别</h3><ul>
<li>语法更加简洁、清晰</li>
<li>箭头函数没有自己的 <code>this</code></li>
<li>箭头函数继承而来的 <code>this</code> 指向永远不变</li>
<li><code>call</code>,<code>apply</code>,<code>bind</code>无法改变箭头函数中 <code>this</code> 的指向</li>
<li>箭头函数不能作为构造函数使用 (为什么)</li>
<li>箭头函数没有自己的 <code>arguments</code> (为什么)</li>
<li>箭头函数没有原型 <code>prototype</code> (为什么)</li>
<li>箭头函数不能用作 <code>Generator</code> 函数，不能使用 <code>yeild</code> 关键字 (为什么)</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions#%E8%A7%A3%E6%9E%90%E9%A1%BA%E5%BA%8F">解析顺序</a> 虽然箭头函数中的箭头不是运算符，但箭头函数具有与常规函数不同的特殊运算符优先级解析规则。</li>
</ul>
<p><a href="https://juejin.cn/post/6844903805960585224">ES6 - 箭头函数、箭头函数与普通函数的区别</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a></p>
<h3 id="javascript-闭包"><a href="#javascript-闭包" class="headerlink" title="javascript 闭包"></a>javascript 闭包</h3><h3 id="javascript-的作用域"><a href="#javascript-的作用域" class="headerlink" title="javascript 的作用域"></a>javascript 的作用域</h3><h3 id="javascript-变量向上找取的原理-执行上下文"><a href="#javascript-变量向上找取的原理-执行上下文" class="headerlink" title="javascript 变量向上找取的原理(执行上下文)"></a>javascript 变量向上找取的原理(执行上下文)</h3><h3 id="javascript-的语法分析"><a href="#javascript-的语法分析" class="headerlink" title="javascript 的语法分析"></a>javascript 的语法分析</h3><h3 id="javascript-的词法分析"><a href="#javascript-的词法分析" class="headerlink" title="javascript 的词法分析"></a>javascript 的词法分析</h3><p><a href="https://juejin.cn/post/6943550570515038245">https://juejin.cn/post/6943550570515038245</a></p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><pre class="language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; es5
function PersonFn () &#123;&#125;

function SupermanFn() &#123;&#125;

SupermanFn.prototype &#x3D; new PersonFn()


&#x2F;&#x2F; es6
class Person () &#123;&#125;

class Superman extends Person &#123;&#125;</code></pre>

<h3 id="洋葱模型"><a href="#洋葱模型" class="headerlink" title="洋葱模型"></a>洋葱模型</h3><pre class="language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; 类似递归
&#x2F;&#x2F; 在 next 中执行下一个function, 依次递归
&#x2F;&#x2F; 如果不好理解可以参考&#96;tapable&#96; 中代码的实现, &#96;tapable&#96;是把所有函数铺平，依次嵌套
&#x2F;&#x2F; 而下面的实现是对依次嵌套改成了递归嵌套
&#x2F;&#x2F; 以上是个人理解
function compose (middleware) &#123;
   return async function () &#123;
      let args &#x3D; arguments
      async function dispatch (i) &#123;
         const fn &#x3D; middleware[i]
         if (!fn) return null
         await fn(function next () &#123;
            dispatch(i + 1)
         &#125;, ...args)
      &#125;

      await dispatch(0)
   &#125;
&#125;

let middleware &#x3D; []
middleware.push((next) &#x3D;&gt; &#123;
	console.log(0)
	next()
	console.log(&quot;next:&quot;, 3.3)
&#125;)
middleware.push((next) &#x3D;&gt; &#123;
	console.log(1)
	next()
	console.log(&quot;next:&quot;, 1.1)
&#125;)
middleware.push(() &#x3D;&gt; &#123;
    console.log(2)
&#125;)

let fn &#x3D; compose(middleware)
fn() &#x2F;&#x2F; 0 1 2 next:1.1 next:3.3
</code></pre>

<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="浏览器的进程（Chrome）"><a href="#浏览器的进程（Chrome）" class="headerlink" title="浏览器的进程（Chrome）"></a>浏览器的进程（Chrome）</h3><ul>
<li>Browser Process 浏览器的主进程（负责协调、主控） （1）负责包括地址栏，书签栏，前进后退按钮等部分的工作 （2）负责处理浏览器的一些不可见的底层操作，比如网络请求和文件访问 （3）负责各个页面的管理，创建和销毁其他进程</li>
<li>Utility Process</li>
<li>Render Process 负责一个 tab 内关于网页呈现的所有事情，页面渲染，脚本执行，事件处理等</li>
<li>GPU Process 负责控制一个网页用到的所有插件，如 flash 每种类型的插件对应一个进程，仅当使用该插件时才创建</li>
<li>Plugin Process 负责处理 GPU 相关的任务</li>
</ul>
<p><a href="https://juejin.cn/post/6844903812642111501">浏览器多线程和 js 单线程</a></p>
<h3 id="在浏览器输入-URL-回车之后发生了什么"><a href="#在浏览器输入-URL-回车之后发生了什么" class="headerlink" title="在浏览器输入 URL 回车之后发生了什么"></a>在浏览器输入 URL 回车之后发生了什么</h3><p><a href="https://zhuanlan.zhihu.com/p/80551769">在浏览器输入 URL 回车之后发生了什么</a></p>
<h3 id="浏览器-GC"><a href="#浏览器-GC" class="headerlink" title="浏览器 GC"></a>浏览器 GC</h3><h2 id="node"><a href="#node" class="headerlink" title="node"></a>node</h2><h3 id="npm-执行命令的流程"><a href="#npm-执行命令的流程" class="headerlink" title="npm 执行命令的流程"></a>npm 执行命令的流程</h3><h3 id="eventloop"><a href="#eventloop" class="headerlink" title="eventloop"></a>eventloop</h3><h3 id="前端页面优化"><a href="#前端页面优化" class="headerlink" title="前端页面优化"></a>前端页面优化</h3><ul>
<li>压缩 js&#x2F;css&#x2F;html&#x2F;图片，减少请求流量</li>
<li>合并小文件都一个文件中，减少请求数</li>
<li>静态资源使用 CDN</li>
<li>图片尽量使用 webp等压缩效果比较好的图片格式 ， 可以使用picture标签</li>
<li>服务端开启 gzip等压缩</li>
<li>使用PWA</li>
<li>使用缓存</li>
<li>图片懒加载&#x2F;使用雪碧图&#x2F;使用 svg</li>
<li>使用 js 懒加载&#x2F;预加载</li>
<li>减少 dom 的层级嵌套</li>
<li>避免 table 布局</li>
<li>css3 开启 GPU 加速</li>
<li>避免重定向</li>
<li>接口使用异步请求</li>
<li>尽量减少请求</li>
<li>如果有必要可以使用Workers</li>
<li>避免&#x2F;减少重排与重绘</li>
</ul>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="http1-和-http2-的区别"><a href="#http1-和-http2-的区别" class="headerlink" title="http1 和 http2 的区别"></a>http1 和 http2 的区别</h3><h3 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h3><h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><h3 id="TypeScript-的类型"><a href="#TypeScript-的类型" class="headerlink" title="TypeScript 的类型"></a>TypeScript 的类型</h3><p><code>any</code>,<code>string</code>,<code>number</code>,<code>boolean</code>,<code>Symbol</code>,<code>Array</code>,<code>null</code>,<code>unknow</code>,<code>never</code>,<code>void</code> …</p>
<h3 id="TypeScript-中-any、never、unknown、null-amp-undefined-和-void-有什么区别？"><a href="#TypeScript-中-any、never、unknown、null-amp-undefined-和-void-有什么区别？" class="headerlink" title="TypeScript 中 any、never、unknown、null &amp; undefined 和 void 有什么区别？"></a>TypeScript 中 any、never、unknown、null &amp; undefined 和 void 有什么区别？</h3><pre class="language-none"><code class="language-none">any: 动态的变量类型（失去了类型检查的作用）。
never: 永不存在的值的类型。例如：never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。
unknown: 任何类型的值都可以赋给  unknown  类型，但是  unknown  类型的值只能赋给  unknown  本身和  any  类型。
null &amp; undefined: 默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把  null 和 undefined 赋值给 number 类型的变量。当你指定了 --strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们各自。
void: 没有任何类型。例如：一个函数如果没有返回值，那么返回值可以定义为 void。

作者：周姐日常事
链接：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;6999985372440559624
来源：稀土掘金</code></pre>

<h3 id="TypeScript-联合类型"><a href="#TypeScript-联合类型" class="headerlink" title="TypeScript 联合类型"></a>TypeScript 联合类型</h3><h3 id="TypeScript-中如何联合枚举类型的-Key"><a href="#TypeScript-中如何联合枚举类型的-Key" class="headerlink" title="TypeScript 中如何联合枚举类型的 Key?"></a>TypeScript 中如何联合枚举类型的 Key?</h3><pre class="language-typescript" data-language="typescript"><code class="language-typescript">enum str &#123;
  A,
  B,
  C
&#125;
type strUnion &#x3D; keyof typeof str; &#x2F;&#x2F; &#39;A&#39; | &#39;B&#39; | &#39;C&#39;</code></pre>

<h3 id="type-和-interface-的区别"><a href="#type-和-interface-的区别" class="headerlink" title="type 和 interface 的区别"></a>type 和 interface 的区别</h3><h3 id="协变、逆变、双变和抗变的理解？"><a href="#协变、逆变、双变和抗变的理解？" class="headerlink" title="协变、逆变、双变和抗变的理解？"></a>协变、逆变、双变和抗变的理解？</h3><pre class="language-typescript" data-language="typescript"><code class="language-typescript">协变：X &#x3D; Y Y 类型可以赋值给 X 类型的情况就叫做协变，也可以说是 X 类型兼容 Y 类型
interface X &#123; name: string; age: number; &#125;
interface Y &#123; name: string; age: number; hobbies: string[] &#125;
let x: X &#x3D; &#123; name: &#39;xiaoming&#39;, age: 16 &#125;
let y: Y &#x3D; &#123; name: &#39;xiaohong&#39;, age: 18, hobbies: [&#39;eat&#39;] &#125;
x &#x3D; y
复制代码
逆变：printY &#x3D; printX 函数X 类型可以赋值给函数Y 类型，因为函数Y 在调用的时候参数是按照Y类型进行约束的，但是用到的是函数X的X的属性和方法，ts检查结果是类型安全的。这种特性就叫做逆变，函数的参数有逆变的性质。
let printY: (y: Y) &#x3D;&gt; void
printY &#x3D; (y) &#x3D;&gt; &#123; console.log(y.hobbies) &#125;
let printX: (x: X) &#x3D;&gt; void
printX &#x3D; (x) &#x3D;&gt; &#123; console.log(x.name) &#125;
printY &#x3D; printX
复制代码
双变（双向协变）：X &#x3D; Y；Y &#x3D; X父类型可以赋值给子类型，子类型可以赋值给父类型，既逆变又协变，叫做“双向协变”（ts2.x 之前支持这种赋值，之后 ts 加了一个编译选项 strictFunctionTypes，设置为 true 就只支持函数参数的逆变，设置为 false 则支持双向协变）
抗变（不变）：非父子类型之间不会发生型变，只要类型不一样就会报错
</code></pre>

<h3 id="declare，declare-global-是什么？"><a href="#declare，declare-global-是什么？" class="headerlink" title="declare，declare global 是什么？"></a>declare，declare global 是什么？</h3><p>declare 是用来定义全局变量、全局函数、全局命名空间、js modules、class 等<br>declare global 为全局对象 window 增加新的属性</p>
<h3 id="TypeScript-类中成员的-public、private、protected、readonly-修饰符的理解"><a href="#TypeScript-类中成员的-public、private、protected、readonly-修饰符的理解" class="headerlink" title="TypeScript 类中成员的 public、private、protected、readonly 修饰符的理解"></a>TypeScript 类中成员的 public、private、protected、readonly 修饰符的理解</h3><p>public: 成员都默认为 public，被此限定符修饰的成员是可以被外部访问；<br>private: 被此限定符修饰的成员是只可以被类的内部访问；<br>protected: 被此限定符修饰的成员是只可以被类的内部以及类的子类访问;<br>readonly: 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。</p>
<h3 id="keyof-和-typeof-关键字的作用"><a href="#keyof-和-typeof-关键字的作用" class="headerlink" title="keyof 和 typeof 关键字的作用"></a>keyof 和 typeof 关键字的作用</h3><p>keyof 索引类型查询操作符 获取索引类型的属性名，构成联合类型。<br>typeof 获取一个变量或对象的类型。</p>
<h3 id="工具类型-Partial、Required、Readonly、Record、Extract、ReturnType、Exclude、Omit-的作用"><a href="#工具类型-Partial、Required、Readonly、Record、Extract、ReturnType、Exclude、Omit-的作用" class="headerlink" title="工具类型 Partial、Required、Readonly、Record、Extract、ReturnType、Exclude、Omit 的作用"></a>工具类型 Partial、Required、Readonly、Record、Extract、ReturnType、Exclude、Omit 的作用</h3><h3 id="实现一个递归的类型"><a href="#实现一个递归的类型" class="headerlink" title="实现一个递归的类型"></a>实现一个递归的类型</h3><h3 id="TypeScript-中-、-、-、-、-、-等符号的含义"><a href="#TypeScript-中-、-、-、-、-、-等符号的含义" class="headerlink" title="TypeScript 中 ?.、??、!、!.、_、** 等符号的含义"></a>TypeScript 中 ?.、??、!、!.、_、** 等符号的含义</h3><p>?. 可选链 遇到 null 和 undefined 可以立即停止表达式的运行。<br>?? 空值合并运算符 当左侧操作数为 null 或 undefined 时，其返回右侧的操作数，否则返回左侧的操作数。<br>! 非空断言运算符 x! 将从 x 值域中排除 null 和 undefined<br>!. 在变量名后添加，可以断言排除 undefined 和 null 类型<br>_ 数字分割符 分隔符不会改变数值字面量的值，使人更容易读懂数字 .e.g 1_101_324。<br>** 求幂</p>
<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h3 id="hooks"><a href="#hooks" class="headerlink" title="hooks"></a>hooks</h3><h3 id="react-diff"><a href="#react-diff" class="headerlink" title="react diff"></a>react diff</h3><h3 id="fiber"><a href="#fiber" class="headerlink" title="fiber"></a>fiber</h3><h2 id="算法或代码实现"><a href="#算法或代码实现" class="headerlink" title="算法或代码实现"></a>算法或代码实现</h2><h3 id="异步加法-字节"><a href="#异步加法-字节" class="headerlink" title="异步加法(字节)"></a>异步加法(字节)</h3><pre class="language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; const addRemote &#x3D; async (a, b) &#x3D;&gt; new Promise(resolve &#x3D;&gt; &#123;
&#x2F;&#x2F;     setTimeout(() &#x3D;&gt; resolve(a + b), 1000)
&#x2F;&#x2F; &#125;)

&#x2F;&#x2F; const addRemote &#x3D; async (a, b) &#x3D;&gt; new Promise(resolve &#x3D;&gt;
&#x2F;&#x2F;     setTimeout ( () &#x3D;&gt; resolve(a + b), 1000)
&#x2F;&#x2F; 2):
&#x2F;&#x2F; async function add (...inputs) &#123;
&#x2F;&#x2F; &#125;
&#x2F;&#x2F; addmte
&#x2F;&#x2F; &#x2F;&#x2F; 的加法。
&#x2F;&#x2F; async function add(..inputs) &#123;
&#x2F;&#x2F; 1你的实现
&#x2F;&#x2F; &#x2F;&#x2F; 川请用示例验证运行结果：
&#x2F;&#x2F; add(1, 2). then(result &#x3D;&gt; &#123;
&#x2F;&#x2F; console.log(result): &#x2F;&#x2F; 3
&#x2F;&#x2F; add(1, 2, 3, 4) .then(result &#x3D;&gt; f
&#x2F;&#x2F; console.log(result): &#x2F;&#x2F; 10
&#x2F;&#x2F; add(1, 2, 1, 2, 1, 2. 3, 4). then(result &#x3D;&gt; f
&#x2F;&#x2F; console.log(result): &#x2F;&#x2F; 16
&#x2F;&#x2F; &#125;)</code></pre>

<h2 id="实现-EventEmitter-模型，实现-on-once-off-emit-方法"><a href="#实现-EventEmitter-模型，实现-on-once-off-emit-方法" class="headerlink" title="实现 EventEmitter 模型，实现 on, once, off, emit 方法"></a>实现 EventEmitter 模型，实现 <code>on</code>, <code>once</code>, <code>off</code>, <code>emit</code> 方法</h2><pre class="language-typescript" data-language="typescript"><code class="language-typescript">class EventEmitter &#123;
  _event: Record&lt;string, Array&lt;Function&gt;&gt;;
  constructor() &#123;
    this._event &#x3D; &#123;&#125;;
  &#125;

  on(type: string, callback: Function) &#123;
    if (this._event[type]) &#123;
      this._event[type].push(callback);
    &#125; else &#123;
      this._event[type] &#x3D; [callback];
    &#125;
    return this;
  &#125;

  once(type: string, callback: Function) &#123;
    let fn &#x3D; (...args: Array&lt;any&gt;) &#x3D;&gt; &#123;
      callback.apply(this, args);
      this.off(type, fn);
    &#125;;
    this.on(type, fn);
    return this;
  &#125;

  off(type: string, callback: Function) &#123;
    if (this._event[type]) &#123;
      this._event[type] &#x3D; this._event[type].filter(item &#x3D;&gt; item !&#x3D;&#x3D; callback);
    &#125;
    return this;
  &#125;

  emit(type: string) &#123;
    this._event[type].map(item &#x3D;&gt; item());
    return this;
  &#125;
&#125;

const eventEmitter &#x3D; new EventEmitter();

let handle1 &#x3D; () &#x3D;&gt; console.log(&quot;click1&quot;);
let handle2 &#x3D; () &#x3D;&gt; console.log(&quot;click2&quot;);
let handle3 &#x3D; () &#x3D;&gt; console.log(&quot;click3&quot;);
let handle4 &#x3D; () &#x3D;&gt; console.log(&quot;click4&quot;);

eventEmitter.on(&quot;click&quot;, handle1);
eventEmitter.on(&quot;click&quot;, handle2);
eventEmitter.once(&quot;click&quot;, handle3);
eventEmitter.emit(&quot;click&quot;);
eventEmitter.emit(&quot;click&quot;);</code></pre>

<h3 id="观察者模式，请实现-observable-和-observe-两个函数"><a href="#观察者模式，请实现-observable-和-observe-两个函数" class="headerlink" title="观察者模式，请实现 observable 和 observe 两个函数"></a>观察者模式，请实现 observable 和 observe 两个函数</h3><pre class="language-typescript" data-language="typescript"><code class="language-typescript"></code></pre>

<h3 id="字符串隐藏部分内容-阿里"><a href="#字符串隐藏部分内容-阿里" class="headerlink" title="字符串隐藏部分内容 (阿里)"></a>字符串隐藏部分内容 (阿里)</h3><p>实现一个方法，接收一个字符串和一个符号，将字符串中间四位按指定符号隐藏</p>
<ol>
<li>符号无指定时使用星号（*）</li>
<li>接收的字符串小于或等于四位时，返回同样长度的符号串，等同于全隐藏，如 123，隐藏后是***</li>
<li>字符串长度是大于四位的奇数时，如 123456789，隐藏后是 12789，奇数多出来的一位在末尾</li>
</ol>
<p>示例：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">mask(&quot;alibaba&quot;, &quot;#&quot;); &#x2F;&#x2F; a####ba
mask(&quot;85022088&quot;); &#x2F;&#x2F; 85****88
mask(&quot;hello&quot;); &#x2F;&#x2F; ****o
mask(&quot;abc&quot;, &quot;?&quot;); &#x2F;&#x2F; ???
mask(&quot;阿里巴巴集团&quot;, &quot;?&quot;); &#x2F;&#x2F; 阿????团</code></pre>

<p>实现</p>
<pre class="language-typescript" data-language="typescript"><code class="language-typescript">function mask(str, char &#x3D; &quot;*&quot;) &#123;
  if (str.length &lt;&#x3D; 4) return char.repeat(str.length);
  &#x2F;* 代码实现 *&#x2F;
  let result &#x3D; &quot;&quot;;
  let i &#x3D; Math.floor(str.length &#x2F; 2) - 1;
  let j &#x3D; Math.floor(str.length &#x2F; 2);
  while (result.length !&#x3D;&#x3D; str.length) &#123;
    if (j - i &lt;&#x3D; 4) &#123;
      result &#x3D; char + result;
      result +&#x3D; char;
    &#125; else &#123;
      result &#x3D; (str[i] || &quot;&quot;) + result;
      result +&#x3D; str[j];
    &#125;
    i--;
    j++;
  &#125;
  return result;
&#125;</code></pre>

<p>实现来源：<a href="https://github.com/FrankKai/FrankKai.github.io/issues/245">https://github.com/FrankKai/FrankKai.github.io/issues/245</a></p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><pre class="language-typescript" data-language="typescript"><code class="language-typescript">function HashMap() &#123;
  this.map &#x3D; &#123;&#125;;
&#125;
HashMap.prototype &#x3D; &#123;
  get: function (key) &#123;
    console.log(this);
    if (this.map.hasOwnProperty(key)) &#123;
      return this.map[key];
    &#125;
    return null;
  &#125;,
  put: function (key, val) &#123;
    this.map[key] &#x3D; val;
  &#125;,
  remove: function (key) &#123;
    if (this.map.hasOwnProperty(key)) &#123;
      let tmp &#x3D; this.map[key];
      delete this.map[key];
      return tmp;
    &#125;
    return null;
  &#125;,
  clear: function () &#123;
    this.map &#x3D; &#123;&#125;;
  &#125;,
  keySet: function () &#123;
    let _keys &#x3D; [];
    for (const key in this.map) &#123;
      _keys.push(key);
    &#125;
    return _keys;
  &#125;
&#125;;
HashMap.prototype.constructor &#x3D; HashMap;
let hashMap &#x3D; new HashMap();</code></pre>

<h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><h3 id="DFS-深度优先"><a href="#DFS-深度优先" class="headerlink" title="DFS 深度优先"></a>DFS 深度优先</h3><h3 id="广度优先"><a href="#广度优先" class="headerlink" title="广度优先"></a>广度优先</h3>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown</title>
    <url>/2023/02/27/markdown/</url>
    <content><![CDATA[<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>使用数字加<code>.</code> 加空格开头</p>
<pre class="language-markdown" data-language="markdown"><code class="language-markdown">1. 有序列表 1
2. 有序列表 2
3. 有序列表 3</code></pre>

<ol>
<li>有序列表 1</li>
<li>有序列表 2</li>
<li>有序列表 3</li>
</ol>
<h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>使用<code>-</code> 加空格开头</p>
<pre class="language-markdown" data-language="markdown"><code class="language-markdown">- 无序列表
- 无序列表
- 无序列表
  - 无序列表
  - 无序列表</code></pre>

<ul>
<li>无序列表</li>
<li>无序列表</li>
<li>无序列表<ul>
<li>无序列表</li>
<li>无序列表</li>
</ul>
</li>
</ul>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>使用<code>#</code>加空格开头</p>
<h3 id="Heading-H3"><a href="#Heading-H3" class="headerlink" title="Heading H3"></a>Heading H3</h3><h4 id="Heading-H4"><a href="#Heading-H4" class="headerlink" title="Heading H4"></a>Heading H4</h4><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>使用<code>&gt;</code>开头</p>
<pre class="language-markdown" data-language="markdown"><code class="language-markdown">&gt; 对于美德，我们仅止于认识是不够的，我们还必须努力培养它，运用它，或是采取种种方法，以使我们成为良善之人。 --莎士比亚

&gt; &gt; 黑夜无论怎样悠长，白昼总会到来。

&gt; &gt; &gt; To be or not to be,that&#39;s a question. --莎士比亚</code></pre>

<blockquote>
<p>对于美德，我们仅止于认识是不够的，我们还必须努力培养它，运用它，或是采取种种方法，以使我们成为良善之人。 –莎士比亚</p>
</blockquote>
<blockquote>
<blockquote>
<p>黑夜无论怎样悠长，白昼总会到来。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>To be or not to be,that’s a question. –莎士比亚</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="粗体"><a href="#粗体" class="headerlink" title="粗体"></a>粗体</h2><p>使用<code>**</code>进行包括</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">**粗体**</code></pre>

<p><strong>粗体</strong></p>
<h2 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h2><p>使用<code>*</code>或<code>_</code>进行包括</p>
<pre class="language-markdown" data-language="markdown"><code class="language-markdown">_斜体_</code></pre>

<p><em>斜体</em></p>
<h2 id="斜体加粗"><a href="#斜体加粗" class="headerlink" title="斜体加粗"></a>斜体加粗</h2><p>使用<code>**</code>进行包括</p>
<pre class="language-markdown" data-language="markdown"><code class="language-markdown">**_斜体_**</code></pre>

<p><strong><em>斜体</em></strong></p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><code>![img alt的值](图片地址)</code></p>
<pre class="language-markdown" data-language="markdown"><code class="language-markdown">![ShineShao](https:&#x2F;&#x2F;avatars2.githubusercontent.com&#x2F;u&#x2F;16034259?s&#x3D;460&amp;u&#x3D;7caff2589de5d263f44675662d8f1a5b91a1d706&amp;v&#x3D;4)</code></pre>

<p><img src="https://avatars2.githubusercontent.com/u/16034259?s=460&u=7caff2589de5d263f44675662d8f1a5b91a1d706&v=4" alt="ShineShao"></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><code>[链接名](链接地址)</code></p>
<pre class="language-markdown" data-language="markdown"><code class="language-markdown">&#123;&#x2F;_ 链接 _&#x2F;&#125;
[ShineShao](https:&#x2F;&#x2F;github.com&#x2F;freeshineit)

&#123;&#x2F;_ 图片链接 _&#x2F;&#125;
[![ShineShao](https:&#x2F;&#x2F;avatars2.githubusercontent.com&#x2F;u&#x2F;16034259?s&#x3D;460&amp;u&#x3D;7caff2589de5d263f44675662d8f1a5b91a1d706&amp;v&#x3D;4)](https:&#x2F;&#x2F;github.com&#x2F;freeshineit)</code></pre>

<p><a href="https://github.com/freeshineit">ShineShao</a></p>
<p><a href="https://github.com/freeshineit"><img src="https://avatars2.githubusercontent.com/u/16034259?s=460&u=7caff2589de5d263f44675662d8f1a5b91a1d706&v=4" alt="ShineShao"></a></p>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>使用至少连续的三个<code>-</code></p>
<pre class="language-markdown" data-language="markdown"><code class="language-markdown">---</code></pre>

<hr>
<h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p>使用<code>~~</code>进行包括</p>
<pre class="language-markdown" data-language="markdown"><code class="language-markdown">~~分割线~~</code></pre>

<p><del>分割线</del></p>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><pre class="language-markdown" data-language="markdown"><code class="language-markdown">| 表头     |   表头   |     表头 |
| :------- | :------: | -------: |
| 内容居左 | 内容居中 | 内容居右 |</code></pre>

<table>
<thead>
<tr>
<th align="left">表头</th>
<th align="center">表头</th>
<th align="right">表头</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单元格</td>
<td align="center">单元格</td>
<td align="right">单元格单元格单元格单元格</td>
</tr>
<tr>
<td align="left">单元格</td>
<td align="center">单元格单元格单元格单元格</td>
<td align="right">单元格</td>
</tr>
</tbody></table>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><pre class="language-go" data-language="go"><code class="language-go">package main;

import &quot;fmt&quot;;

func main () &#123;
  fmt.Println(&quot;Hello World&quot;)
&#125;</code></pre>

<h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><pre class="language-diff" data-language="diff"><code class="language-diff">+ 123
- 123412</code></pre>

<h2 id="普通文本"><a href="#普通文本" class="headerlink" title="普通文本"></a>普通文本</h2><p>每个人都会有缺陷，就像被上帝咬过的苹果，有的人缺陷比较大，正是因为上帝特别喜欢他的芬芳。</p>
<h2 id="checkbox"><a href="#checkbox" class="headerlink" title="checkbox"></a>checkbox</h2><pre class="language-markdown" data-language="markdown"><code class="language-markdown">- [ ] 任务一 未做任务 &#96;- + 空格 + [ ]&#96;
- [x] 任务二 已做任务 &#96;- + 空格 + [x]&#96;</code></pre>

<ul>
<li><input disabled="" type="checkbox"> 任务一 未做任务 <code>- + 空格 + [ ]</code></li>
<li><input checked="" disabled="" type="checkbox"> 任务二 已做任务 <code>- + 空格 + [x]</code></li>
</ul>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><pre class="language-markdown" data-language="markdown"><code class="language-markdown">[&#x2F;&#x2F;]: # &quot;注释&quot;</code></pre>

<h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><pre class="language-markdown" data-language="markdown"><code class="language-markdown">&amp;nbsp; 空格
&lt; &lt;
&gt; &gt;
&amp; &amp;
&amp;yen; ¥
&amp;copy; ©
&amp;reg; ®
&amp;deg;C °C
&amp;plusmn; ±
&amp;times; ×
&amp;divide; ÷
m&amp;sup2; m²
m&amp;sup3; m³</code></pre>

<p>&amp;nbsp;<br>&lt;<br>&gt;<br>&amp;<br>&amp;yen;<br>&amp;copy;<br>&amp;reg;<br>&amp;deg;C<br>&amp;plusmn;<br>&amp;times;<br>&amp;divide;<br>m&amp;sup2;<br>m&amp;sup3;</p>
<h2 id="details"><a href="#details" class="headerlink" title="details"></a>details</h2><pre class="language-markdown" data-language="markdown"><code class="language-markdown">&lt;details&gt;
  &lt;summary&gt;展开&lt;&#x2F;summary&gt;
  Something small enough to escape casual notice.
&lt;&#x2F;details&gt;</code></pre>

<details>
  <summary>展开</summary>
  Something small enough to escape casual notice.
</details>

<h2 id="表情"><a href="#表情" class="headerlink" title="表情"></a>表情</h2><pre class="language-markdown" data-language="markdown"><code class="language-markdown">🐶 👍
😁 🔕</code></pre>

<p>🐶 👍<br>😁 🔕</p>
<h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><pre class="language-markdown" data-language="markdown"><code class="language-markdown">使用 &#96;Markdown&#96;[^1]可以效率的书写文档, 直接转换成 &#96;HTML&#96;[^2], 你可以使用 &#96;Typora&#96;[^t] 编辑器进行书写。

[^1]: Markdown 是一种纯文本标记语言
[^2]: HyperText Markup Language 超文本标记语言
[^t]: [NEW WAY TO READ &amp; WRITE MARKDOWN.](https:&#x2F;&#x2F;www.baidu.com)</code></pre>

<p>使用 <code>Markdown</code>[^1]可以效率的书写文档, 直接转换成 <code>HTML</code>[^2], 你可以使用 <code>Typora</code>[^t] 编辑器进行书写。</p>
<p>[^1]: Markdown 是一种纯文本标记语言<br>[^2]: HyperText Markup Language 超文本标记语言<br>[^t]: <a href="https://www.baidu.com/">NEW WAY TO READ &amp; WRITE MARKDOWN.</a></p>
<p><a href="LICENSE">MIT</a> © <a href="https://github.com/freeshineit">ShineShao</a></p>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Sass 语法</title>
    <url>/2022/10/08/css/scss/</url>
    <content><![CDATA[<h2 id="each-使用说明"><a href="#each-使用说明" class="headerlink" title="@each 使用说明"></a><code>@each</code> 使用说明</h2><p>The <a href="https://sass-lang.com/documentation/at-rules/control/each">@each</a> rule makes it easy to emit styles or evaluate code for each element of a list or each pair in a map. It’s great for repetitive styles that only have a few variations between them. It’s usually written</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><pre class="language-scss" data-language="scss"><code class="language-scss">$sizes: 40px, 50px, 80px;
@each $size in $sizes &#123;
  .icon-#&#123;$size&#125; &#123;
    font-size: $size;
    height: $size;
    width: $size;
  &#125;
&#125;

# result .icon-40px &#123;
  font-size: 40px;
  height: 40px;
  width: 40px;
&#125;

.icon-50px &#123;
  font-size: 50px;
  height: 50px;
  width: 50px;
&#125;

.icon-80px &#123;
  font-size: 80px;
  height: 80px;
  width: 80px;
&#125;</code></pre>

<pre class="language-scss" data-language="scss"><code class="language-scss">&#x2F;&#x2F; 数组
$countries: ((ad, 376), (ae, 971)), ((az, 994), (ba, 387));
$offset: -32px;

@each $arr in $countries &#123;
  &#x2F;&#x2F; get index (form 1)
  $i: index($countries, $arr); &#x2F;&#x2F; &#x3D;&gt; number | null

  @each $c in $arr &#123;
    $j: index($arr, $c);

    .flag.flag-#&#123;nth($c, 1)&#125; &#123;
      background-position: $offset * ($j - 1) $offset * ($i - 1);
    &#125;
  &#125;
&#125;

# result .flag.flag-ad &#123;
  background-position: 0px 0px;
&#125;
.flag.flag-ae &#123;
  background-position: -32px 0px;
&#125;
.flag.flag-az &#123;
  background-position: 0px -32px;
&#125;
.flag.flag-ba &#123;
  background-position: -32px -32px;
&#125;</code></pre>]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>Sass</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 常用命令</title>
    <url>/2023/02/18/git/antic/</url>
    <content><![CDATA[<h1 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h1><pre class="language-bash" data-language="bash"><code class="language-bash"># rebase
git rebase master

# 解决冲突后
git add .

# continue
git rebase --continue</code></pre>

<pre class="language-bash" data-language="bash"><code class="language-bash"># discard 丢弃缓存
git reset HEAD

# 丢弃指定文件缓存
git reset HEAD &lt;file&gt;

# 撤销最新的commit
git reset HEAD^

# 修改最新的一次commit 日志
git commit --amend
## 或者使用别名
git ca
</code></pre>

<h3 id="使用-执行多条命令"><a href="#使用-执行多条命令" class="headerlink" title="使用; 执行多条命令"></a>使用<code>;</code> 执行多条命令</h3><pre class="language-bash" data-language="bash"><code class="language-bash">git add .; git status</code></pre>

<h3 id="配置命令别名（Aliases）"><a href="#配置命令别名（Aliases）" class="headerlink" title="配置命令别名（Aliases）"></a>配置命令别名（<a href="https://git-scm.com/book/zh-tw/v2/Git-%E5%9F%BA%E7%A4%8E-Git-Aliases">Aliases</a>）</h3><p>git 默认配置了部分别名，可以使用<code>git config --list</code> 查看</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"># git commit -m
# git config --global alias.cm commit -m
git cm

# git log --stat --abbrev-commit
# git config --global alias.ll log --stat --abbrev-commit
git ll

# git diff
# git config --global alias.d diff
git d</code></pre>

<p>配置别名命令</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"># 配置别名命令
git config --global alias.st status

# 使用 git st 相当于 git status
git st</code></pre>

<p>git log 别名配置</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"># git l
git config --global alias.l &quot;log --graph --all --pretty&#x3D;format:&#39;%C(yellow)%h%C(cyan)%d%Creset %s %C(white)- %an, %ar%Creset&#39;&quot;

# git ll
git config --global alias.ll &quot;log --stat --abbrev-commit&quot;

# git lg
git config --global alias.lg &quot;log --color --graph --pretty&#x3D;format:&#39;%C(bold white)%h%Creset -%C(bold green)%d%Creset %s %C(bold green)(%cr)%Creset %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit --date&#x3D;relative&quot;

# git llg
git config --global alias.llg &quot;log --color --graph --pretty&#x3D;format:&#39;%C(bold white)%H %d%Creset%n%s%n%+b%C(bold blue)%an &lt;%ae&gt;%Creset %C(bold green)%cr (%ci)&#39; --abbrev-commit&quot;</code></pre>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Tool</tag>
      </tags>
  </entry>
  <entry>
    <title>下载github上项目指定的文件夹</title>
    <url>/2022/02/09/github/download/</url>
    <content><![CDATA[<h2 id="node-实现下载指定文件或文件夹"><a href="#node-实现下载指定文件或文件夹" class="headerlink" title="node 实现下载指定文件或文件夹"></a>node 实现下载指定文件或文件夹</h2><p><a href="https://github.com/qqxs/got-github-examples">got-github-examples</a></p>
<ol>
<li>创建存储的文件夹</li>
</ol>
<pre class="language-typescript" data-language="typescript"><code class="language-typescript">import fs from &quot;fs&quot;;

export function makeDir(
  root: string,
  options &#x3D; &#123; recursive: true &#125;
): Promise&lt;string | undefined&gt; &#123;
  return fs.promises.mkdir(root, options);
&#125;</code></pre>

<ol start="2">
<li>下载指定的文件夹或文件</li>
</ol>
<pre class="language-typescript" data-language="typescript"><code class="language-typescript">import got from &quot;got&quot;;
import tar from &quot;tar&quot;;
import path from &quot;path&quot;;
import &#123; Stream &#125; from &quot;stream&quot;;
import &#123; promisify &#125; from &quot;util&quot;;
import &#123; makeDir &#125; from &quot;.&#x2F;make-dir&quot;;

const pipeline &#x3D; promisify(Stream.pipeline);

&#x2F;&#x2F; tar extract 内容放置的路径
const root &#x3D; path.resolve(&quot;data-fetch-app&quot;);

async function downloadExample() &#123;
  await makeDir(root);
  process.chdir(root);
  return pipeline(
    got.stream(
      &#x2F;&#x2F; &#96;https:&#x2F;&#x2F;codeload.github.com&#x2F;$&#123;user&#125;&#x2F;$&#123;repo&#125;&#x2F;tar.gz&#x2F;$&#123;branch&#125;&#96;
      &#x2F;&#x2F; example
      &#96;https:&#x2F;&#x2F;codeload.github.com&#x2F;qqxs&#x2F;got-github-examples&#x2F;tar.gz&#x2F;main&#96;
    ),
    tar.extract(
      &#123;
        cwd: root,
        strip: 3 &#x2F;&#x2F; 层级
      &#125;,
      &#x2F;&#x2F; [&#96;$&#123;repo&#125;-$&#123;branch&#125;&#x2F;$&#123;examplePath&#125;&#96;]
      &#x2F;&#x2F; example
      [&#96;got-github-examples-main&#x2F;examples&#x2F;example01&#96;]
    )
  );
&#125;

downloadExample();</code></pre>

<ol start="3">
<li>执行</li>
</ol>
<pre class="language-bash" data-language="bash"><code class="language-bash">ts-node index.ts</code></pre>

<h2 id="curl-实现下载指定文件或文件夹"><a href="#curl-实现下载指定文件或文件夹" class="headerlink" title="curl 实现下载指定文件或文件夹"></a>curl 实现下载指定文件或文件夹</h2><pre class="language-bash" data-language="bash"><code class="language-bash"># mkdir my-app &amp;&amp; curl https:&#x2F;&#x2F;codeload.github.com&#x2F;[user]&#x2F;[repo]&#x2F;tar.gz&#x2F;[branch] | tar -xz -C my-app --strip&#x3D;2 [repo]-[branch]&#x2F;[examplePath]
# 下载github上&#96;freeshineit&#x2F;next-examples&#96;的 main分支下 &#96;with-typescript-eslint-jest-app&#96; 文件夹下所有的文件和文件夹
mkdir my-app &amp;&amp; curl https:&#x2F;&#x2F;codeload.github.com&#x2F;freeshineit&#x2F;next-examples&#x2F;tar.gz&#x2F;main | tar -xz -C my-app --strip&#x3D;2 next-examples-main&#x2F;with-typescript-eslint-jest-app</code></pre>
]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>got</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang Sync</title>
    <url>/2023/02/18/golang/sync/</url>
    <content><![CDATA[<h2 id="golang-goroutine-同步操作"><a href="#golang-goroutine-同步操作" class="headerlink" title="golang goroutine 同步操作"></a>golang goroutine 同步操作</h2><h3 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a><a href="https://golang.org/pkg/sync/#WaitGroup">sync.WaitGroup</a></h3><pre class="language-go" data-language="go"><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;sync&quot;
	&quot;time&quot;
)

func worker(i int, wg *sync.WaitGroup) &#123;
	fmt.Printf(&quot;sync worker %d starting\n&quot;, i)
	time.Sleep(time.Second)
	fmt.Printf(&quot;sync worker %d done\n&quot;, i)
	defer wg.Done()
&#125;

&#x2F;&#x2F; sync.WaitGroup
func SyncWaitGroup() &#123;
	var wg sync.WaitGroup
	fmt.Println(&quot;this is SyncWaitGroup func&quot;)
	for i :&#x3D; 1; i &lt;&#x3D; 10; i++ &#123;
		&#x2F;&#x2F; 创建10个 goroutine
		wg.Add(1)
		go worker(i, &amp;wg)
	&#125;
	wg.Wait()
&#125;
</code></pre>

<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a><a href="https://blog.golang.org/pipelines">Channel</a></h3><pre class="language-go" data-language="go"><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;time&quot;
)

func chanWorker(i int, done chan int) &#123;
	fmt.Printf(&quot;chan worker %d starting\n&quot;, i)
	time.Sleep(time.Second)
	fmt.Printf(&quot;chan worker %d done\n&quot;, i)
	done &lt;- i
&#125;

&#x2F;&#x2F; chan
func Channel() &#123;
	c :&#x3D; make(chan int)
	fmt.Println(&quot;this is Channel func&quot;)
	for i :&#x3D; 1; i &lt;&#x3D; 10; i++ &#123;
		&#x2F;&#x2F; 创建10个 goroutine
		go chanWorker(i, c)
	&#125;
	&lt;-c
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>goroutine</tag>
        <tag>channel</tag>
      </tags>
  </entry>
  <entry>
    <title>Gulp 源码分析</title>
    <url>/2022/11/28/gulp/source/</url>
    <content><![CDATA[<h2 id="Gulp"><a href="#Gulp" class="headerlink" title="Gulp"></a>Gulp</h2><pre class="language-javascript" data-language="javascript"><code class="language-javascript">&quot;use strict&quot;;

var util &#x3D; require(&quot;util&quot;);
&#x2F;&#x2F; https:&#x2F;&#x2F;www.npmjs.com&#x2F;package&#x2F;undertaker
&#x2F;&#x2F; undertaker类提供了task，series，parallel，get，set，tree和registry方法
&#x2F;&#x2F; undertaker类继承于node核心类eventemitter
var Undertaker &#x3D; require(&quot;undertaker&quot;);
&#x2F;&#x2F; https:&#x2F;&#x2F;www.npmjs.com&#x2F;package&#x2F;vinyl-fs
&#x2F;&#x2F; vinyl是vitual file formate虚拟文件格式，用于描述一个文件。
&#x2F;&#x2F; 它有两个主要的属性，path属性和contents属性。每一个Vinyl实例代表一个独立的文件、目录或者symlink符号连接。
var vfs &#x3D; require(&quot;vinyl-fs&quot;);
&#x2F;&#x2F; https:&#x2F;&#x2F;www.npmjs.com&#x2F;package&#x2F;glob-watcher
&#x2F;&#x2F; 观察globs并在更改时执行一个函数，并使用智能默认值取消绑定和排队。
var watch &#x3D; require(&quot;glob-watcher&quot;);

function Gulp() &#123;
  &#x2F;&#x2F; 改变Undertaker的this 指向，指向Gulp
  Undertaker.call(this);

  &#x2F;&#x2F; Bind the functions for destructuring
  this.watch &#x3D; this.watch.bind(this);
  &#x2F;&#x2F; 任务。 由undertaker类提供
  this.task &#x3D; this.task.bind(this);
  &#x2F;&#x2F; 任务顺序依次执行。 由undertaker类提供
  this.series &#x3D; this.series.bind(this);
  &#x2F;&#x2F; 将任务功能或组合操作组合成并行执行的较大操作。 由undertaker类提供
  this.parallel &#x3D; this.parallel.bind(this);
  &#x2F;&#x2F; https:&#x2F;&#x2F;www.gulpjs.com.cn&#x2F;docs&#x2F;api&#x2F;registry&#x2F;
  &#x2F;&#x2F; 允许将自定义的注册表插入到任务系统中，以期提供共享任务或增强功能。
  &#x2F;&#x2F; 由undertaker类提供
  this.registry &#x3D; this.registry.bind(this);
  &#x2F;&#x2F; 获取当前任务依赖关系树。 由undertaker类提供
  this.tree &#x3D; this.tree.bind(this);
  &#x2F;&#x2F; 由undertaker类提供
  this.lastRun &#x3D; this.lastRun.bind(this);
  &#x2F;&#x2F; 创建一个流，用于从文件系统读取 Vinyl 对象。由 vinyl-fs 提供
  this.src &#x3D; this.src.bind(this);
  &#x2F;&#x2F; 创建一个用于将 Vinyl 对象写入到文件系统的流。由 vinyl-fs 提供
  this.dest &#x3D; this.dest.bind(this);
  &#x2F;&#x2F; 符号链接。 由 vinyl-fs 提供
  this.symlink &#x3D; this.symlink.bind(this);
&#125;

&#x2F;&#x2F; https:&#x2F;&#x2F;nodejs.org&#x2F;docs&#x2F;latest&#x2F;api&#x2F;util.html#utilinheritsconstructor-superconstructor
&#x2F;&#x2F; 继承
&#x2F;&#x2F; 已经不建议使用了， 最好使用es6的继承方式  extends
util.inherits(Gulp, Undertaker);

&#x2F;&#x2F; https:&#x2F;&#x2F;www.npmjs.com&#x2F;package&#x2F;vinyl-fs#options
&#x2F;&#x2F; vfs.src(globs[, options])
Gulp.prototype.src &#x3D; vfs.src;
&#x2F;&#x2F; https:&#x2F;&#x2F;www.npmjs.com&#x2F;package&#x2F;vinyl-fs#destfolder-options
&#x2F;&#x2F; vfs.dest(folder[, options])
&#x2F;&#x2F; 将文件夹路径字符串或函数作为第一个参数，将选项对象作为第二个参数。
&#x2F;&#x2F; 如果给定一个函数，它将与每个vinyl File对象一起调用，并且必须返回文件夹路径。
&#x2F;&#x2F; 返回一个流，该流接受vinyl File对象，将它们写入指定文件夹&#x2F;cwd中的磁盘，并将它们传递到下游，这样您就可以继续使用管道。
&#x2F;&#x2F; 一旦文件写入磁盘后，将尝试确定vinyl File对象的&#96;stat.mode&#96;、&#96;stat.mtime&#96;和&#96;stat.atime&#96;是否与文件系统上的文件不同。
&#x2F;&#x2F; 如果它们不同，并且正在运行的进程拥有该文件，则会更新相应的文件系统元数据。
&#x2F;&#x2F; 如果它们没有差异或进程不拥有文件，则会自动跳过尝试。
&#x2F;&#x2F; 如果文件具有指定目标路径的&#96;symlink&#96;属性，则将创建&#96;symlink&#96;。
Gulp.prototype.dest &#x3D; vfs.dest;

&#x2F;&#x2F; https:&#x2F;&#x2F;www.npmjs.com&#x2F;package&#x2F;vinyl-fs#symlinkfolder-options
&#x2F;&#x2F; vfs.symlink(folder[, options])
&#x2F;&#x2F; 将文件夹路径字符串或函数作为第一个参数，将选项对象作为第二个参数。
&#x2F;&#x2F; 如果给定一个函数，它将与每个vinyl File对象一起调用，并且必须返回文件夹路径。
&#x2F;&#x2F; 返回一个流，该流接受vinyl File对象，在指定的文件夹&#x2F;cwd处创建一个&#96;symlink&#96;，并将其传递到下游，这样您就可以继续使用管道传递这些对象。
Gulp.prototype.symlink &#x3D; vfs.symlink;
&#x2F;&#x2F; 在 &#96;glob-watcher&#96; 前做校验和兼容
&#x2F;&#x2F;
Gulp.prototype.watch &#x3D; function (glob, opt, task) &#123;
  if (
    typeof opt &#x3D;&#x3D;&#x3D; &quot;string&quot; ||
    typeof task &#x3D;&#x3D;&#x3D; &quot;string&quot; ||
    Array.isArray(opt) ||
    Array.isArray(task)
  ) &#123;
    throw new Error(
      &quot;watching &quot; +
        glob +
        &quot;: watch task has to be &quot; +
        &quot;a function (optionally generated by using gulp.parallel &quot; +
        &quot;or gulp.series)&quot;
    );
  &#125;

  if (typeof opt &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123;
    task &#x3D; opt;
    opt &#x3D; &#123;&#125;;
  &#125;

  opt &#x3D; opt || &#123;&#125;;

  var fn;
  if (typeof task &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123;
    fn &#x3D; this.parallel(task);
  &#125;

  &#x2F;&#x2F; watch() 方法时通过 &#96;events&#96; 参数进行指定。
  &#x2F;&#x2F; 可用的事件有 &#39;add&#39;、&#39;addDir&#39;、&#39;change&#39;、&#39;unlink&#39;、&#39;unlinkDir&#39;、&#39;ready&#39;、&#39;error&#39;。
  &#x2F;&#x2F; 此外，还有一个 &#39;all&#39; 事件，它表示除 &#39;ready&#39; 和 &#39;error&#39; 之外的所有事件。
  return watch(glob, opt, fn);
&#125;;

&#x2F;&#x2F; Let people use this class from our instance
Gulp.prototype.Gulp &#x3D; Gulp;
&#x2F;&#x2F; Gulp 实例
var inst &#x3D; new Gulp();
module.exports &#x3D; inst;</code></pre>
]]></content>
      <categories>
        <category>Gulp</category>
      </categories>
      <tags>
        <tag>Tool</tag>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript apply,call和bind</title>
    <url>/2022/10/26/js/apply_call_bind/</url>
    <content><![CDATA[<h2 id="apply-原理"><a href="#apply-原理" class="headerlink" title="apply 原理"></a>apply 原理</h2><p><a href="">apply</a> xxxx</p>
<h2 id="apply-实现"><a href="#apply-实现" class="headerlink" title="apply 实现"></a>apply 实现</h2><pre class="language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;**
 *
 *&#x2F;
function _apply(_this: any, args: any[]) &#123;&#125;

(function () &#123;
  &#x2F;&#x2F; npx ts-node app&#x2F;typeof.ts
  &#x2F;&#x2F; 如果有错 会有打印
  const assert &#x3D; require(&quot;assert&quot;);
&#125;)();</code></pre>

<h2 id="call-原理"><a href="#call-原理" class="headerlink" title="call 原理"></a>call 原理</h2><p><a href="">call</a> xxxx</p>
<h2 id="call-实现"><a href="#call-实现" class="headerlink" title="call 实现"></a>call 实现</h2><pre class="language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;**
 *
 *&#x2F;
function _call(_this: any, ...args: any[]) &#123;&#125;

(function () &#123;
  &#x2F;&#x2F; npx ts-node app&#x2F;typeof.ts
  &#x2F;&#x2F; 如果有错 会有打印
  const assert &#x3D; require(&quot;assert&quot;);
&#125;)();</code></pre>

<h2 id="bind-原理"><a href="#bind-原理" class="headerlink" title="bind 原理"></a>bind 原理</h2><p><a href="">bind</a> xxxx</p>
<h2 id="bind-实现"><a href="#bind-实现" class="headerlink" title="bind 实现"></a>bind 实现</h2><pre class="language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;**
 *
 *&#x2F;
function _bind(_this: any, ...args: any[]) &#123;&#125;

(function () &#123;
  &#x2F;&#x2F; npx ts-node app&#x2F;typeof.ts
  &#x2F;&#x2F; 如果有错 会有打印
  const assert &#x3D; require(&quot;assert&quot;);
&#125;)();</code></pre>

<h2 id="apply-call-和-bind-共同点"><a href="#apply-call-和-bind-共同点" class="headerlink" title="apply, call 和 bind 共同点"></a>apply, call 和 bind 共同点</h2><h2 id="apply-call-和-bind-不同点"><a href="#apply-call-和-bind-不同点" class="headerlink" title="apply, call 和 bind 不同点"></a>apply, call 和 bind 不同点</h2>]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript instanceof 原理</title>
    <url>/2022/10/26/js/instanceof/</url>
    <content><![CDATA[<h2 id="instanceof-原理"><a href="#instanceof-原理" class="headerlink" title="instanceof 原理"></a>instanceof 原理</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof">instanceof</a> 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre class="language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;**
 *
 * 简单模拟 instanceof的实现
 *
 * https:&#x2F;&#x2F;developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Operators&#x2F;instanceof
 *
 * instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。
 *
 * 需要注意的是，如果表达式 obj instanceof Foo 返回 true，则并不意味着该表达式会永远返回 true，
 * 因为 Foo.prototype 属性的值有可能会改变，改变之后的值很有可能不存在于 obj 的原型链上，
 * 这时原表达式的值就会成为 false。另外一种情况下，原表达式的值也会改变，就是改变对象 obj 的原型链的情况，虽然在目前的 ES 规范中，
 * 我们只能读取对象的原型而不能改变它，但借助于非标准的 __proto__ 伪属性，是可以实现的。
 * 比如执行 obj.__proto__ &#x3D; &#123;&#125; 之后，obj instanceof Foo 就会返回 false 了。
 *
 *
 * @param instance 实例对象
 * @param Func 构造函数
 * @returns boolean
 *&#x2F;
function _instanceof(instance: any, Func: any) &#123;
  let instance_proto &#x3D; instance.__proto__;
  let FuncProto &#x3D; Func.prototype;

  while (true) &#123;
    if (instance_proto &#x3D;&#x3D;&#x3D; null) &#123;
      return false;
    &#125;
    if (instance_proto &#x3D;&#x3D;&#x3D; FuncProto) &#123;
      return true;
    &#125;

    instance_proto &#x3D; instance_proto.__proto__;
  &#125;
&#125;

(function () &#123;
  &#x2F;&#x2F; npx ts-node app&#x2F;typeof.ts
  &#x2F;&#x2F; 如果有错 会有打印
  const assert &#x3D; require(&quot;assert&quot;);

  &#x2F;&#x2F; 定义构造函数
  function C() &#123;&#125;
  function D() &#123;&#125;

  let o &#x3D; new (C as any)();

  assert.equal(o instanceof C, _instanceof(o, C));
  assert.equal(o instanceof Object, _instanceof(o, Object));
  assert.equal(C.prototype instanceof Object, _instanceof(C.prototype, Object));

  &#x2F;&#x2F;
  C.prototype &#x3D; &#123;&#125;;
  let o2 &#x3D; new (C as any)();
  assert.equal(o instanceof C, _instanceof(o2, C));

  &#x2F;&#x2F;  false，C.prototype 指向了一个空对象，这个空对象不在 o 的原型链上。
  assert.equal(false, _instanceof(o, C));

  D.prototype &#x3D; new (C as any)(); &#x2F;&#x2F; 继承

  let o3 &#x3D; new (D as any)();

  assert.equal(o3 instanceof D, _instanceof(o3, D));

  &#x2F;&#x2F; true 因为 C.prototype 现在在 o3 的原型链上
  assert.equal(o3 instanceof C, _instanceof(o3, C));
&#125;)();</code></pre>]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript typeof 原理</title>
    <url>/2022/10/25/js/typeof/</url>
    <content><![CDATA[<h2 id="typeof-原理"><a href="#typeof-原理" class="headerlink" title="typeof 原理"></a>typeof 原理</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof">typeof</a> 运算符返回一个字符串，表示操作数的类型。</p>
<p>javascript 在底层存储变量的时候,会在变量的机器码的低位(前三位) 1-3 位存储其类型信息: 对象:000 (null 是 000， 这也是 null 的 typeof 值为什么是 object 的原因) 浮点数:010 字符串:100 布尔:110 ”。<br><code>typeof</code>直接根据变量值得内存标识符进行判断并返回的是对应字符串形式的值。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre class="language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;**
 * 模拟 typeof
 *
 * typeof原理：
 * js 在底层存储变量的时候,会在变量的机器码的低位1-3位存储其类型信息: 对象:000 (null 是 000， 这也是 null 的typeof 值为什么是object的原因) 浮点数:010 字符串:100 布尔:110 ”。
 * typeof直接根据变量值得内存标识符进行判断并返回的是对应字符串形式的值。
 *
 * 实现：
 * 1. 创建一个枚举对象
 * 2. 利用 Object.prototype.toString.call 来获取类型
 * 3. 再对 Number, String, Boolean 对象进行特殊处理
 *
 * @param target any
 * @returns string
 *&#x2F;
function _typeof(target: any) &#123;
  const EnumMap &#x3D; &#123;
    [&quot;[object Number]&quot;]: &quot;number&quot;,
    [&quot;[object String]&quot;]: &quot;string&quot;,
    [&quot;[object Object]&quot;]: &quot;object&quot;,
    [&quot;[object Array]&quot;]: &quot;object&quot;,
    [&quot;[object Null]&quot;]: &quot;object&quot;,
    [&quot;[object Boolean]&quot;]: &quot;boolean&quot;,
    [&quot;[object Function]&quot;]: &quot;function&quot;,
    [&quot;[object Undefined]&quot;]: &quot;undefined&quot;,
    [&quot;[object Symbol]&quot;]: &quot;symbol&quot;,
    [&quot;[object BigInt]&quot;]: &quot;bigint&quot;,
    [&quot;[object Set]&quot;]: &quot;object&quot;,
    [&quot;[object Map]&quot;]: &quot;object&quot;
  &#125;;

  const key: keyof typeof EnumMap &#x3D; Object.prototype.toString.call(target);

  &#x2F;&#x2F;  这个几个特殊处理一下
  if (
    [&quot;[object Number]&quot;, &quot;[object String]&quot;, &quot;[object Boolean]&quot;].includes(key) &amp;&amp;
    target instanceof Object
  ) &#123;
    return &quot;object&quot;;
  &#125;
  return EnumMap[key];
&#125;

&#x2F;&#x2F; npx ts-node app&#x2F;typeof.ts
&#x2F;&#x2F; 如果有错 会有打印
const assert &#x3D; require(&quot;assert&quot;);
&#x2F;&#x2F; test
assert.equal(typeof 12312, _typeof(12312));
assert.equal(typeof new Number(12312), _typeof(new Number(12312)));
&#x2F;&#x2F;
assert.equal(typeof true, _typeof(true));
assert.equal(typeof false, _typeof(false));
assert.equal(typeof new Boolean(true), _typeof(new Boolean(true)));
assert.equal(typeof new Boolean(false), _typeof(new Boolean(false)));
&#x2F;&#x2F;
assert.equal(typeof &quot;string&quot;, _typeof(&quot;string&quot;));
assert.equal(typeof new String(&quot;string&quot;), _typeof(new String(&quot;string&quot;)));

&#x2F;&#x2F; object
assert.equal(typeof &#123;&#125;, _typeof(&#123;&#125;));
assert.equal(typeof new Object(&#123;&#125;), _typeof(new Object(&#123;&#125;)));
assert.equal(typeof Object.create(&#123;&#125;), _typeof(Object.create(&#123;&#125;)));
&#x2F;&#x2F;
assert.equal(typeof [], _typeof([]));
assert.equal(typeof new Array(), _typeof(new Array()));
&#x2F;&#x2F;
assert.equal(typeof null, _typeof(null));
&#x2F;&#x2F;
assert.equal(typeof undefined, _typeof(undefined));

&#x2F;&#x2F;
assert.equal(
  typeof (() &#x3D;&gt; &#123;&#125;),
  _typeof(() &#x3D;&gt; &#123;&#125;)
);
assert.equal(
  typeof function a() &#123;&#125;,
  _typeof(function a() &#123;&#125;)
);
assert.equal(typeof new Function(), _typeof(new Function()));

&#x2F;&#x2F;
assert.equal(typeof Symbol, _typeof(Symbol));
assert.equal(typeof Symbol(), _typeof(Symbol()));

&#x2F;&#x2F; &#x2F;&#x2F; bigint
&#x2F;&#x2F; assert.equal(typeof 123n, _typeof(123n));
&#x2F;&#x2F; assert.equal(typeof new BigInt(123n), _typeof(new BigInt(123n)));

assert.equal(typeof new Set(), _typeof(new Set()));
assert.equal(typeof new Set([1, 2, 3, 4]), _typeof(new Set([1, 2, 3, 4])));

&#x2F;&#x2F;
assert.equal(typeof new Map(), _typeof(new Map()));

&#x2F;&#x2F;
class Point &#123;&#125;

let point &#x3D; new Point();

assert.equal(typeof Point, _typeof(Point));
assert.equal(typeof point, _typeof(point));</code></pre>]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript 版 React 别名（alias）</title>
    <url>/2021/11/10/react/jsconfig/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>虽然说近几年已经不在写 javascript 版 React 了，一直在用 typescript 但是最近接了个外包，其他小伙伴不太熟 typescript。所以就打算配置一下使用 javascript 环境项目的别名。</p>
<p>使用<a href="https://create-react-app.dev/">create-react-app</a> 创建 javascript 版 React 项目，安装 <a href="https://github.com/gsoft-inc/craco"><code>@craco/craco</code></a>。</p>
<p>具体配置省略，接下来主要说用别名的配置。（想要了解具体配置请参考<a href="https://github.com/gsoft-inc/craco/blob/master/packages/craco/README.md#installation%EF%BC%89">https://github.com/gsoft-inc/craco/blob/master/packages/craco/README.md#installation）</a></p>
<h2 id="craco-中配置-webpack"><a href="#craco-中配置-webpack" class="headerlink" title="craco 中配置 webpack"></a>craco 中配置 webpack</h2><p>在根目录<code>craco.config.js</code>文件中配置别名</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">module.exports &#x3D; &#123;
  webpack: &#123;
    &#x2F;&#x2F; .... 其他配置
    alias: &#123;
      &#x2F;&#x2F; 文件路径别名
      &quot;@&quot;: path.resolve(__dirname, &quot;src&quot;),
      &quot;@components&quot;: path.resolve(__dirname, &quot;src&#x2F;components&quot;),
      &quot;@utils&quot;: path.resolve(__dirname, &quot;src&#x2F;utils&quot;),
      &quot;@assets&quot;: path.resolve(__dirname, &quot;src&#x2F;assets&quot;),
      &quot;@containers&quot;: path.resolve(__dirname, &quot;src&#x2F;containers&quot;),
      &quot;@hooks&quot;: path.resolve(__dirname, &quot;src&#x2F;hooks&quot;),
      &quot;@store&quot;: path.resolve(__dirname, &quot;src&#x2F;store&quot;)
    &#125;
  &#125;
&#125;;</code></pre>

<h2 id="jsconfig-json"><a href="#jsconfig-json" class="headerlink" title="jsconfig.json"></a>jsconfig.json</h2><p>在根目录下新建<code>jsconfig.json</code>, 添加下面内容即可。</p>
<pre class="language-json" data-language="json"><code class="language-json">&#123;
  &quot;compilerOptions&quot;: &#123;
    &quot;module&quot;: &quot;commonjs&quot;,
    &quot;jsx&quot;: &quot;preserve&quot;,
    &quot;baseUrl&quot;: &quot;.&quot;,
    &quot;paths&quot;: &#123;
      &quot;@components&#x2F;*&quot;: [&quot;.&#x2F;src&#x2F;components&#x2F;*&quot;],
      &quot;@assets&#x2F;*&quot;: [&quot;.&#x2F;src&#x2F;assets&#x2F;*&quot;],
      &quot;@containers&#x2F;*&quot;: [&quot;.&#x2F;src&#x2F;containers&#x2F;*&quot;],
      &quot;@hooks&#x2F;*&quot;: [&quot;.&#x2F;src&#x2F;hooks&#x2F;*&quot;],
      &quot;@store&#x2F;*&quot;: [&quot;.&#x2F;src&#x2F;store&#x2F;*&quot;],
      &quot;@utils&#x2F;*&quot;: [&quot;.&#x2F;src&#x2F;utils&#x2F;*&quot;]
    &#125;
  &#125;,
  &quot;include&quot;: [&quot;.&#x2F;src&#x2F;**&#x2F;*&quot;],
  &quot;exclude&quot;: [&quot;node_modules&quot;, &quot;build&quot;, &quot;coverage&quot;, &quot;dist&quot;, &quot;lib&quot;]
&#125;</code></pre>

<p>注意 ⚠️： 这个文件有严格的 json 格式要求， 例如最后一项不能有<code>,</code> 等</p>
<p>❤️ ❤️ 还是 ts 香 ❤️ ❤️</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>docker nginx 部署React项目</title>
    <url>/2021/12/11/react/nginx_deploy/</url>
    <content><![CDATA[<h2 id="docker-nginx"><a href="#docker-nginx" class="headerlink" title="docker nginx"></a>docker nginx</h2><ol>
<li>在项目根目录下新建 <code>docker-compose.yml</code>文件</li>
</ol>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml">version: &quot;2&quot;
services:
  # 服务名称
  nginx:
    # 镜像:版本
    image: nginx:latest
    # 映射容器80端口到本地80端口
    ports:
      - &quot;80:80&quot;
    # 数据卷 映射本地文件到容器
    # 这个更新起来特别香
    volumes:
      # 映射nginx.conf文件到容器的&#x2F;etc&#x2F;nginx&#x2F;conf.d目录并覆盖default.conf文件
      - .&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf
      # 映射build文件夹到容器的&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html文件夹
      - .&#x2F;build:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html
    # 覆盖容器启动后默认执行的命令。
    command: &#x2F;bin&#x2F;bash -c &quot;nginx -g &#39;daemon off;&#39;&quot;</code></pre>

<p>挂载 nginx 配置</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">location &#x2F; &#123;
    root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;
    index  index.html index.htm;
    # 其作用是按顺序检查文件是否存在，返回第一个找到的文件或文件夹（结尾加斜线表示为文件夹），如果所有的文件或文件夹都找不到，会进行一个内部重定向到最后一个参数。
    try_files $uri &#x2F;index.html;
&#125;

# 接口代理
location ^~ &#x2F;api&#x2F; &#123;
    # proxy_set_header X-Forwarded-Host $host;
    # proxy_set_header X-Forwarded-Server $host;
    # proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_pass http:&#x2F;&#x2F;xxx.xxxxx.xxxx;
&#125;</code></pre>

<ol start="2">
<li>编译 react 项目</li>
</ol>
<pre class="language-bash" data-language="bash"><code class="language-bash">yarn run build</code></pre>

<ol start="3">
<li>生成容器并部署</li>
</ol>
<pre class="language-bash" data-language="bash"><code class="language-bash">docker-compose up -d</code></pre>

<ol start="4">
<li><p>本地访问 <code>http://localhost/</code></p>
</li>
<li><p>停止并删除容器 <code>docker-compose down</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>React</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>svg 转图片</title>
    <url>/2023/02/24/svg/to_image/</url>
    <content><![CDATA[<h2 id="svg-转图片"><a href="#svg-转图片" class="headerlink" title="svg 转图片"></a>svg 转图片</h2><pre class="language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 序列化 svg 文件（xml） 转成字符串
const svgString &#x3D; new XMLSerializer()
  .serializeToString(document.getElementById(&#39;svg&#39;));

const img &#x3D; new Image();
&#x2F;&#x2F; svgString svg的xml文件字符串
const svg &#x3D; new Blob([svgString], &#123;type: &quot;image&#x2F;svg+xml;charset&#x3D;utf-8&quot;&#125;);

const domURL &#x3D; self.URL || self.webkitURL || self;
const url &#x3D; domURL.createObjectURL(svg);

img.src &#x3D; url;

&#x2F;&#x2F; append img to body
&#x2F;&#x2F; ...</code></pre>

]]></content>
      <categories>
        <category>Svg</category>
      </categories>
      <tags>
        <tag>Svg</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 工具</title>
    <url>/2023/02/18/tools/mac/</url>
    <content><![CDATA[<h2 id="homebrew"><a href="#homebrew" class="headerlink" title="homebrew"></a><a href="https://brew.sh/">homebrew</a></h2><p><a href="https://brew.sh/">homebrew</a> 安装 <code>/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;</code></p>
<ol>
<li><p>安装插件</p>
<ul>
<li>安装 <a href="https://git-scm.com/">git</a></li>
</ul>
<p><code>brew install git</code></p>
<ul>
<li>安装 <a href="https://github.com/wting/autojump">autojump</a></li>
</ul>
<p><code>brew install autojump</code></p>
<p>在 ~&#x2F;.zshrc 中找到<code>plugins</code> 添加 <code>autojump</code>, 注意 ⚠️ 每个插件间用空格隔开</p>
</li>
</ol>
<h2 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a><a href="https://iterm2.com/">iTerm2</a></h2><ol>
<li><p>安装插件</p>
<ul>
<li>安装 <a href="https://ohmyz.sh/">oh-my-zsh</a> 主题</li>
</ul>
<pre class="language-bash" data-language="bash"><code class="language-bash">sh -c &quot;\$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;robbyrussell&#x2F;oh-my-zsh&#x2F;master&#x2F;tools&#x2F;install.sh)&quot;</code></pre>

<ul>
<li>安装 <a href="https://github.com/zsh-users/zsh-autosuggestions">zsh-autosuggestions</a></li>
</ul>
<pre class="language-bash" data-language="bash"><code class="language-bash">git clone https:&#x2F;&#x2F;github.com&#x2F;zsh-users&#x2F;zsh-autosuggestions $&#123;ZSH_CUSTOM:-~&#x2F;.oh-my-zsh&#x2F;custom&#125;&#x2F;plugins&#x2F;zsh-autosuggestions</code></pre>

<p>在 ~&#x2F;.zshrc 中找到<code>plugins</code> 添加 <code>zsh-autosuggestions</code>, 注意 ⚠️ 每个插件间用空格隔开</p>
<ul>
<li>安装 <a href="https://github.com/zsh-users/zsh-syntax-highlighting">zsh-syntax-highlighting</a></li>
</ul>
<pre class="language-bash" data-language="bash"><code class="language-bash">git clone https:&#x2F;&#x2F;github.com&#x2F;zsh-users&#x2F;zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~&#x2F;.oh-my-zsh&#x2F;custom&#125;&#x2F;plugins&#x2F;zsh-syntax-highlighting</code></pre>

<p>在 ~&#x2F;.zshrc 中找到<code>plugins</code> 添加 <code>zsh-syntax-highlighting</code>, 注意 ⚠️ 每个插件间用空格隔开</p>
<p>最终结果</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">plugins&#x3D;(
 git
 zsh-syntax-highlighting
 zsh-autosuggestions
 autojump
)</code></pre></li>
</ol>
<h2 id="vim-配置"><a href="#vim-配置" class="headerlink" title="vim 配置"></a>vim 配置</h2><p>可以参考 阮一峰老师的 <a href="https://www.ruanyifeng.com/blog/2018/09/vimrc.html">Vim 配置入门</a></p>
<p>在 <code>~/.vimrc</code> 配置 (如果没有请自建<code>touch ~/.vimrc</code>)</p>
<p>我的基本设置</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">set number
syntax on
set mouse&#x3D;a
set encoding&#x3D;utf-8
set autoindent
set tabstop&#x3D;2
set cursorline
set ruler
set showmatch
set incsearch
set hlsearch</code></pre>
]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Tool</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Yarn workspace</title>
    <url>/2021/08/05/tools/yarn_workspace/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p><a href="https://yarnpkg.com/features/workspaces">yarn Workspaces</a> 旨在简化 monorepos 的使用，以更具声明性的方式解决 yarn 链接的主要用例之一。简言之，它们允许您的多个项目一起生活在同一个存储库中，并相互交叉引用——对一个项目的源代码的任何修改都会立即应用于其他项目。</p>
<p>首先，一些词汇：在工作区特性的上下文中，项目是组成工作区的整个目录树（通常是存储库本身）。工作区是由同一项目中您自己的源组成的本地包。最后，工作树是为列出自己的子工作空间的工作空间指定的名称。项目包含一个或多个工作树，这些工作树本身可能包含任意数量的工作空间。任何项目都至少包含一个工作区：根工作区。</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><ul>
<li>初始化</li>
</ul>
<pre class="language-bash" data-language="bash"><code class="language-bash">mkdir yarn_workspaces &amp;&amp; cd yarn_workspaces

# 初始化
# 配置 package.json
yarn init

mkdir packages

# 配置 workspaces
# &quot;workspaces&quot;: [
#  &quot;packages&#x2F;*&quot;
# ]</code></pre>

<ul>
<li>配置根目录下<code>package.json</code></li>
</ul>
<pre class="language-json" data-language="json"><code class="language-json">&#123;
  &quot;private&quot;: true,
  &quot;workspaces&quot;: [&quot;packages&#x2F;*&quot;]
&#125;</code></pre>

<ul>
<li><p>create common package (components、utils…)</p>
<ul>
<li>初始化 <code>@mono/common</code> package</li>
</ul>
<pre class="language-bash" data-language="bash"><code class="language-bash">cd packages &amp;&amp; mkdir common

yarn init -y

mkdir components &amp;&amp; mkdir utils</code></pre>

<ul>
<li>配置 <code>package.json</code></li>
</ul>
<pre class="language-json" data-language="json"><code class="language-json">&#123;
  &quot;name&quot;: &quot;@mono&#x2F;common&quot;,
  &quot;main&quot;: &quot;index.ts&quot;
&#125;</code></pre>

<p>注：由于整个项目都是基于<code>typescript</code>的, 所以 <code>main</code> 就直接指定 <code>index.ts</code>。如果要发布到 npm 上最好还是使用<code>.js</code>。</p>
</li>
<li><p>create mobile web app (html5)</p>
<ul>
<li>初始化 app</li>
</ul>
<pre class="language-bash" data-language="bash"><code class="language-bash">cd packages &amp;&amp; mkdir mobile

# 创建 index.html
touch index.html</code></pre>
</li>
<li><p>create web app (react spa)</p>
<ul>
<li>初始化 app</li>
</ul>
<pre class="language-bash" data-language="bash"><code class="language-bash">cd packages

# 创建 react spa app
yarn create react-app my-app --template typescript</code></pre>

<ul>
<li>scripts</li>
</ul>
<p>在项目根目录下<code>package.json</code>中<code>scripts</code>添加下面脚本</p>
<pre class="language-json" data-language="json"><code class="language-json">&#123;
  &quot;react-sap-app&quot;: &quot;yarn workspace react-spa-app start&quot;
&#125;</code></pre>

<ul>
<li>配置使用本地 package</li>
</ul>
<pre class="language-bash" data-language="bash"><code class="language-bash"># 安装 @craco&#x2F;craco
# 在不执行&#96;eject&#96;的条件下注入webpacke等 配置
yarn add @craco&#x2F;craco -D</code></pre>

<p>在<code>react-spa-app</code>根目录下新建创建<code>craco.config.js</code>文件</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">const path &#x3D; require(&quot;path&quot;);
const &#123; getLoader, loaderByName &#125; &#x3D; require(&quot;@craco&#x2F;craco&quot;);

&#x2F;&#x2F; 配置包括根目录以外文件路径
&#x2F;&#x2F; absolutePath 包名 &#96;@mono&#x2F;common&#96;
&#x2F;&#x2F; 在&#96;react-spa-app&#96;项目中可以直接使用 import nameFn from &quot;@mono&#x2F;common&quot;
const absolutePath &#x3D; path.join(__dirname, &quot;..&#x2F;common&quot;);

module.exports &#x3D; &#123;
  webpack: &#123;
    alias: &#123;&#125;,
    plugins: [],
    configure: (webpackConfig, &#123; env, paths &#125;) &#x3D;&gt; &#123;
      const &#123; isFound, match &#125; &#x3D; getLoader(
        webpackConfig,
        loaderByName(&quot;babel-loader&quot;)
      );
      if (isFound) &#123;
        const include &#x3D; Array.isArray(match.loader.include)
          ? match.loader.include
          : [match.loader.include];
        match.loader.include &#x3D; include.concat[absolutePath];
      &#125;
      return webpackConfig;
    &#125;
  &#125;
&#125;;</code></pre>
</li>
<li><p>create ssr web app (next.js)</p>
<ul>
<li>初始化 ssr web app</li>
</ul>
<pre class="language-bash" data-language="bash"><code class="language-bash">cd packages

# 创建 react ssr app
yarn create next-app --example with-typescript nextjs-app</code></pre>

<ul>
<li>scripts</li>
</ul>
<p>在项目根目录下<code>package.json</code>中<code>scripts</code>添加下面脚本</p>
<pre class="language-json" data-language="json"><code class="language-json">&#123;
  &quot;react-sap-app&quot;: &quot;yarn workspace nextjs-app dev&quot;
&#125;</code></pre>

<ul>
<li>配置使用本地 package</li>
</ul>
<pre class="language-bash" data-language="bash"><code class="language-bash"># 注意⚠️ &#96;next-transpile-modules&#96;版本有很大区别
# https:&#x2F;&#x2F;www.npmjs.com&#x2F;package&#x2F;next-transpile-modules#user-content-compatibility-table
yarn add next-transpile-modules -D</code></pre>

<p>在<code>nextjs-app</code>根目录下新建创建<code>next.config.js</code>文件</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; pass the modules you would like to see transpiled
const withTM &#x3D; require(&quot;next-transpile-modules&quot;)([&quot;@mono&#x2F;common&quot;]);
module.exports &#x3D; withTM();</code></pre>
</li>
<li><p>配置</p>
</li>
<li><p>create service app (koa service)</p>
<ul>
<li>初始化 service app</li>
</ul>
<pre class="language-bash" data-language="bash"><code class="language-bash">
cd packages &amp;&amp; mkdir koa-service-app &amp;&amp; cd koa-service-app

yarn init -y

# 创建服务入口
touch server.ts

yarn add typescript ts-node @types&#x2F;node nodemon -D</code></pre>

<ul>
<li>scripts</li>
</ul>
<p>在<code>koa-service-app</code>目录下<code>package.json</code>中<code>scripts</code>添加下面脚本</p>
<pre class="language-json" data-language="json"><code class="language-json">&#123;
  &quot;dev&quot;: &quot;nodemon --watch &#39;.&#x2F;**&#x2F;*.ts&#39; --watch &#39;..&#x2F;common&#x2F;**&#x2F;*.ts&#39; --exec &#39;ts-node&#39; server.ts&quot;
&#125;</code></pre>

<p>在项目根目录下<code>package.json</code>中<code>scripts</code>添加下面脚本</p>
<pre class="language-json" data-language="json"><code class="language-json">&#123;
  &quot;koa-service-app&quot;: &quot;yarn workspace koa-service-app dev&quot;
&#125;</code></pre></li>
</ul>
<h2 id="scripts-说明"><a href="#scripts-说明" class="headerlink" title="scripts 说明"></a>scripts 说明</h2><pre class="language-bash" data-language="bash"><code class="language-bash"># 启动 mobile app
# 首先已经安装 http-server
http-server -p .&#x2F;package&#x2F;mobile

# 启动 react spa app
yarn workspace react-spa-app start

# 启动 next.js ssr app
yarn workspace nextjs-app dev

# 启动 koa node server
yarn workspace koa-service-app start</code></pre>

<h2 id="yarn-workspace-cli"><a href="#yarn-workspace-cli" class="headerlink" title="yarn workspace cli"></a>yarn workspace cli</h2><pre class="language-bash" data-language="bash"><code class="language-bash"># root install dependency xxxxx
yarn add -W -D xxxxx

# root remove dependency xxxxx
yarn remove -W xxxxx

# package app1 install dependency xxxx
yarn workspace app1 add xxxx

# run app1 dev
yarn workspace app1 dev

# build all package
yarn workspaces run build</code></pre>

<h2 id="提取公共依赖包"><a href="#提取公共依赖包" class="headerlink" title="提取公共依赖包"></a>提取公共依赖包</h2><p>把各个项目中公共依赖提取到根目录<code>package.json</code>中方便统一管理</p>
<pre class="language-json" data-language="json"><code class="language-json">&#123;
  &quot;dependencies&quot;: &#123;
    &quot;react&quot;: &quot;^17.0.2&quot;,
    &quot;react-dom&quot;: &quot;^17.0.2&quot;
  &#125;,
  &quot;devDependencies&quot;: &#123;
    &quot;@craco&#x2F;craco&quot;: &quot;^6.1.2&quot;,
    &quot;@types&#x2F;koa&quot;: &quot;^2.13.3&quot;,
    &quot;@types&#x2F;node&quot;: &quot;^15.12.4&quot;,
    &quot;@types&#x2F;react&quot;: &quot;^17.0.11&quot;,
    &quot;@types&#x2F;react-dom&quot;: &quot;^17.0.8&quot;,
    &quot;koa&quot;: &quot;^2.13.1&quot;,
    &quot;next&quot;: &quot;^11.0.1&quot;,
    &quot;next-transpile-modules&quot;: &quot;^8.0.0&quot;,
    &quot;ts-node&quot;: &quot;^10.0.0&quot;,
    &quot;typescript&quot;: &quot;^4.3.4&quot;,
    &quot;@testing-library&#x2F;jest-dom&quot;: &quot;^5.11.4&quot;,
    &quot;@testing-library&#x2F;react&quot;: &quot;^11.1.0&quot;,
    &quot;@testing-library&#x2F;user-event&quot;: &quot;^12.1.10&quot;,
    &quot;@types&#x2F;jest&quot;: &quot;^26.0.15&quot;,
    &quot;react-scripts&quot;: &quot;4.0.3&quot;
  &#125;
&#125;</code></pre>


<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>如果本地新增 package 记得执行 <code>yarn install</code></li>
</ul>
<h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><p>如果想对版本进行管理可以结合 <a href="https://lerna.js.org/">leran</a></p>
<h2 id="github-地址"><a href="#github-地址" class="headerlink" title="github 地址"></a>github 地址</h2><p><a href="https://github.com/qqxs/monorepo">yarn workspaces monorepo</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://yarnpkg.com/features/workspaces">yarn workspace</a></li>
<li><a href="https://create-react-app.dev/docs/adding-typescript">create-react-app</a></li>
<li><a href="https://nextjs.org/">next.js</a></li>
<li><a href="https://koajs.com/">koa2</a></li>
<li><a href="https://nodemon.io/">nodemon</a></li>
</ul>
]]></content>
      <categories>
        <category>Yarn</category>
      </categories>
      <tags>
        <tag>Tool</tag>
        <tag>Yarn</tag>
      </tags>
  </entry>
  <entry>
    <title>Typescript 类型操作</title>
    <url>/2020/11/21/typescript/type/</url>
    <content><![CDATA[<h2 id="Ts-类型操作"><a href="#Ts-类型操作" class="headerlink" title="Ts 类型操作"></a>Ts 类型操作</h2><ul>
<li>Partial (部分, 把所有字段转为可选字段)</li>
</ul>
<pre class="language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;**
 * Make all properties in T optional
 *&#x2F;
type Partial&lt;T&gt; &#x3D; &#123;
  [P in keyof T]?: T[P];
&#125;;</code></pre>

<p>example：</p>
<pre class="language-typescript" data-language="typescript"><code class="language-typescript">type partial &#x3D; &#123;
  name: string;
  getName(): string;
&#125;;

&#x2F;**
 * TPartial 结果
 * &#123;
 *   name?: string
 *   getName()?: string
 * &#125;
 *&#x2F;
type TPartial &#x3D; Partial&lt;partial&gt;;</code></pre>

<ul>
<li>Required (需要, 把所有字段转为必选字段)</li>
</ul>
<pre class="language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;**
 * Make all properties in T required
 *&#x2F;
type Required&lt;T&gt; &#x3D; &#123;
  [P in keyof T]-?: T[P];
&#125;;</code></pre>

<p>example:</p>
<pre class="language-typescript" data-language="typescript"><code class="language-typescript">type required &#x3D; &#123;
  name?: string;
  getName(): string;
&#125;;

&#x2F;**
 * TRequired 结果
 * &#123;
 *   name: string
 *   getName(): string
 * &#125;
 *&#x2F;
type TRequired &#x3D; Required&lt;required&gt;;</code></pre>

<ul>
<li>Readonly (只读，把所有字段转为只读字段)</li>
</ul>
<pre class="language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;**
 * Make all properties in T readonly
 *&#x2F;
type Readonly&lt;T&gt; &#x3D; &#123;
  readonly [P in keyof T]: T[P];
&#125;;</code></pre>

<p>example:</p>
<pre class="language-typescript" data-language="typescript"><code class="language-typescript">type Treadonly &#x3D; &#123;
  name?: string;
  getName(): string;
&#125;;

&#x2F;**
 * TReadonly 结果
 * &#123;
 *   readonly name?: string
 *   readonly getName(): string
 * &#125;
 *&#x2F;
type TReadonly &#x3D; Readonly&lt;Treadonly&gt;;</code></pre>

<ul>
<li>Pick (挑选, 挑选指定的字段)</li>
</ul>
<pre class="language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;**
 * From T, pick a set of properties whose keys are in the union K
 *&#x2F;
type Pick&lt;T, K extends keyof T&gt; &#x3D; &#123;
  [P in K]: T[P];
&#125;;</code></pre>

<p>example:</p>
<pre class="language-typescript" data-language="typescript"><code class="language-typescript">type pick &#x3D; &#123;
  name?: string;
  age: number;
  getName(): string;
&#125;;

&#x2F;**
 * TPick 结果
 * &#123;
 *   name?: string
 *   age: number
 * &#125;
 *&#x2F;
type TPick &#x3D; Pick&lt;pick, &quot;name&quot; | &quot;age&quot;&gt;;</code></pre>

<ul>
<li>Record(记录,将 K 中所有的属性的值转化为 T 类型)</li>
</ul>
<pre class="language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;**
 * Construct a type with a set of properties K of type T
 *&#x2F;
type Record&lt;K extends keyof any, T&gt; &#x3D; &#123;
  [P in K]: T;
&#125;;</code></pre>

<p>example:</p>
<pre class="language-typescript" data-language="typescript"><code class="language-typescript">type record &#x3D; &#123;
  name?: string;
  age: number;
  getName(): string;
&#125;;

&#x2F;**
 * TRecord 结果
 * &#123;
 *   name: string
 *   age: string
 *   getName: string
 * &#125;
 *&#x2F;
type TRecord &#x3D; Record&lt;keyof record, string&gt;;

&#x2F;**
 * Ta 结果
 * &#123;
 *   a: number
 *   b: number
 *   c: number
 *   1: number
 * &#125;
 *&#x2F;
type Ta &#x3D; Record&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot; | 1, number&gt;;</code></pre>

<ul>
<li>Exclude(排除,从 T 中排除那些可分配给 U 的类型，)</li>
</ul>
<pre class="language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;**
 * Exclude from T those types that are assignable to U
 *&#x2F;
type Exclude&lt;T, U&gt; &#x3D; T extends U ? never : T;</code></pre>

<p>example:</p>
<pre class="language-typescript" data-language="typescript"><code class="language-typescript">type T &#x3D; Exclude&lt;1 | 2, 1 | 3&gt;; &#x2F;&#x2F; -&gt; 2</code></pre>

<ul>
<li>Extract(提取,从 T 中提取可分配给 U 的类型， 交集)</li>
</ul>
<pre class="language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;**
 * Extract from T those types that are assignable to U
 *&#x2F;
type Extract&lt;T, U&gt; &#x3D; T extends U ? T : never;</code></pre>

<p>example:</p>
<pre class="language-typescript" data-language="typescript"><code class="language-typescript">type T &#x3D; Extract&lt;1 | 2, 1 | 3&gt;; &#x2F;&#x2F; -&gt; 1</code></pre>

<ul>
<li>Omit (删去, 构造一个除 K 类型外具有 T 属性的类型。)</li>
</ul>
<pre class="language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;**
 * Construct a type with the properties of T except for those in type K.
 *&#x2F;
type Omit&lt;T, K extends keyof any&gt; &#x3D; Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;</code></pre>

<p>example:</p>
<pre class="language-typescript" data-language="typescript"><code class="language-typescript">interface Person &#123;
  name: string;
  age: number;
  location: string;
&#125;

&#x2F;**
 * OmitPerson 结果
 * &#123;
 *   location: string
 * &#125;
 *&#x2F;
type OmitPerson &#x3D; Omit&lt;Person, &quot;name&quot; | &quot;age&quot;&gt;;</code></pre>

<ul>
<li>数组</li>
</ul>
<pre class="language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;** arr1Example 中只可以使用&#96;string&#96;类型填充 *&#x2F;
type arr1 &#x3D; string[]; &#x2F;&#x2F; 建议使用[]
const arr1Example: arr1 &#x3D; [&quot;123&quot;, &quot;23454&quot;];

&#x2F;** arr2Example 中只可以使用[&#96;string&#96;,&#96;number&#96;]类型填充，必须按顺序填充, 个数也有限制 *&#x2F;
type arr2 &#x3D; [string, number];
const arr2Example: arr2 &#x3D; [&quot;0&quot;, 1];

&#x2F;** arr3Example 中只可以使用&#96;string&#96;或&#96;number&#96;类型填充，没有顺序要求 *&#x2F;
type arr3 &#x3D; (string | number)[];
const arr3Example: arr3 &#x3D; [0, &quot;1&quot;, &quot;2&quot;, 3, 4];</code></pre>

<ul>
<li>对象</li>
</ul>
<pre class="language-typescript" data-language="typescript"><code class="language-typescript">interface Persion&lt;T&gt; &#123;
  [key: T]: T;
&#125;</code></pre>

<ul>
<li><p>extends</p>
</li>
<li><p>keyof (对于任何类型 <code>T</code>， <code>keyof T</code>的结果为 <code>T</code>上已知的公共属性名的联合)</p>
</li>
</ul>
<pre class="language-typescript" data-language="typescript"><code class="language-typescript">interface Person &#123;
  name: string;
  age: number;
&#125;

type p &#x3D; keyof Person; &#x2F;&#x2F; -&gt; p &#x3D; &#39;name&#39; | &#39;age&#39;</code></pre>

<ul>
<li>typeof</li>
</ul>
<pre class="language-typescript" data-language="typescript"><code class="language-typescript"></code></pre>

<ul>
<li>交叉类型 (交叉类型是将多个类型合并为一个类型)</li>
</ul>
<pre class="language-typescript" data-language="typescript"><code class="language-typescript">interface;</code></pre>

<ul>
<li>联合类型 (联合类型表示一个值可以是几种类型之一,用竖线<code>｜</code>分隔每个类型)</li>
</ul>
<pre class="language-typescript" data-language="typescript"><code class="language-typescript">function getNum(num: number | string): number &#123;
  return +num;
&#125;</code></pre>

<ul>
<li>索引类型</li>
</ul>
<pre class="language-typescript" data-language="typescript"><code class="language-typescript"></code></pre>

<ul>
<li>映射类型</li>
</ul>
<pre class="language-typescript" data-language="typescript"><code class="language-typescript"></code></pre>

<ul>
<li>@4.1</li>
</ul>
<pre class="language-typescript" data-language="typescript"><code class="language-typescript">  &#x2F;&#x2F; @4.1
type Getters&lt;T&gt; &#x3D; &#123;
  &#x2F;&#x2F;
  [K in keyof T as &#96;get$&#123;capitalize K&#125;&#96;]: () &#x3D;&gt; T[K]
&#125;

interface Person &#123;
	name: string;
	age: number;
	location: string;
&#125;

&#x2F;**
* LazyPerson 结果
* &#123;
*   name: string
*   age: number
*   location: string
*   getName: () &#x3D;&gt; string
*   getAge: () &#x3D;&gt; number
*   getLocation: () &#x3D;&gt; string
* &#125;
*&#x2F;
type LazyPerson &#x3D; Getters&lt;Person&gt;;</code></pre>

<ul>
<li><p>React 中的类型约束</p>
<ul>
<li>FC (函数组件类型)</li>
</ul>
<pre class="language-tsx" data-language="tsx"><code class="language-tsx">interface FunctionComponent&lt;P &#x3D; &#123;&#125;&gt; &#123;
  (props: PropsWithChildren&lt;P&gt;, context?: any): ReactElement&lt;any, any&gt; | null;
  propTypes?: WeakValidationMap&lt;P&gt;;
  contextTypes?: ValidationMap&lt;any&gt;;
  defaultProps?: Partial&lt;P&gt;;
  displayName?: string;
&#125;

type FC&lt;P &#x3D; &#123;&#125;&gt; &#x3D; FunctionComponent&lt;P&gt;;

&#x2F;&#x2F; 具体使用
interface IProps &#123;&#125;
const App: FC&lt;IProps&gt; &#x3D; props &#x3D;&gt; &lt;div&gt;&#123;props.children&#125;&lt;&#x2F;div&gt;;</code></pre>

<ul>
<li><p>useState</p>
<p>React 中使用<code>useState</code>方法去设置 state</p>
</li>
</ul>
<pre class="language-tsx" data-language="tsx"><code class="language-tsx">function useState&lt;S&gt;(
  initialState: S | (() &#x3D;&gt; S)
): [S, Dispatch&lt;SetStateAction&lt;S&gt;&gt;];</code></pre></li>
</ul>
]]></content>
      <categories>
        <category>Typescript</category>
      </categories>
      <tags>
        <tag>Typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack5 配置项</title>
    <url>/2022/11/13/webpack/config/</url>
    <content><![CDATA[<h2 id="webpack5-配置项"><a href="#webpack5-配置项" class="headerlink" title="webpack5 配置项"></a>webpack5 配置项</h2><p>webpack <a href="https://sourcegraph.com/github.com/webpack/webpack@main/-/blob/declarations/WebpackOptions.d.ts">WebpackOptions</a></p>
<p><a href="https://webpack.docschina.org/configuration/other-options">https://webpack.docschina.org/configuration/other-options</a></p>
<pre class="language-typescript" data-language="typescript"><code class="language-typescript">export interface WebpackOptions &#123;
  &#x2F;**
   * 设置&#96;require.amd&#96;和&#96;define.amd&#96;的值。或者禁用AMD支持。
   *&#x2F;
  amd?: false | &#123; [k: string]: any &#125;;
  &#x2F;**
   * 在第一个错误出现时抛出失败结果，而不是容忍它;  true: 将会致使 webpack 在发现错误时尽快退出。
   *&#x2F;
  bail?: boolean;
  &#x2F;**
   * 缓存生成的 modules 和 chunks，以提高多个增量构建的性能。
   *&#x2F;
  cache?: boolean | MemoryCacheOptions | FileCacheOptions;
  &#x2F;**
   * 基本目录（绝对路径！）用于解析&#96;entry&#96;选项。如果设置了&#96;output.pathinfo&#96;，则包含的pathinfo将缩短到此目录。
   *&#x2F;
  context?: string; &#x2F;&#x2F; Context;
  &#x2F;**
   * 对要依赖的其他配置的引用。
   *&#x2F;
  dependencies?: string[]; &#x2F;&#x2F; Dependencies;
  &#x2F;**
   * https:&#x2F;&#x2F;webpack.js.org&#x2F;configuration&#x2F;dev-server&#x2F;
   * webpack-dev-server的选项
   *&#x2F;
  devServer?: DevServer;
  &#x2F;**
   * 用于增强调试的开发工具 (false | eval | [inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map).
   *&#x2F;
  devtool?: DevTool;
  &#x2F;**
   * 编译的入口点
   *&#x2F;
  entry?: Entry;
  &#x2F;**
   * 启用&#x2F;禁用实验（具有relax-SemVer兼容性的实验功能）
   *&#x2F;
  experiments?: Experiments;
  &#x2F;**
   * 指定不应该由webpack解析，但应该成为结果包的依赖项的依赖项。依赖关系的类型取决于&#96;output.libraryTarget&#96;。
   *&#x2F;
  externals?: Externals;
  &#x2F;**
   * 为特定目标启用外部预设
   *&#x2F;
  externalsPresets?: ExternalsPresets;
  &#x2F;**
   * 指定外部的默认类型（&#39;amd*&#39;、&#39;umd*&#39;，&#39;system&#39;和&#39;jsonp&#39;取决于设置为相同值的output.libraryTarget）。
   *&#x2F;
  externalsType?: ExternalsType;
  &#x2F;**
   * https:&#x2F;&#x2F;webpack.docschina.org&#x2F;configuration&#x2F;other-options&#x2F;#ignorewarnings
   * 忽略特定警告
   *&#x2F;
  ignoreWarnings?: IgnoreWarnings;
  &#x2F;**
   * https:&#x2F;&#x2F;webpack.docschina.org&#x2F;configuration&#x2F;other-options&#x2F;#infrastructurelogging
   * 用于基础设施水平的日志选项
   *&#x2F;
  infrastructureLogging?: InfrastructureLogging;
  &#x2F;**
   * https:&#x2F;&#x2F;webpack.docschina.org&#x2F;configuration&#x2F;other-options&#x2F;#loader
   * loader上下文中可用的自定义值
   *&#x2F;
  loader?: Loader;
  &#x2F;**
   * 启用生产优化或开发提示
   *&#x2F;
  mode?: &quot;development&quot; | &quot;production&quot; | &quot;none&quot;;
  &#x2F;**
   * 影响正常模块的选项（&#96;NormalModuleFactory&#96;）
   *&#x2F;
  module?: ModuleOptions;
  &#x2F;**
   * https:&#x2F;&#x2F;webpack.docschina.org&#x2F;configuration&#x2F;other-options&#x2F;#name
   * 配置的名称。加载多个配置时使用。
   *&#x2F;
  name?: string; &#x2F;&#x2F;Name;
  &#x2F;**
   * 包括各种节点填充的polyfill或mock
   *&#x2F;
  node?: Node;
  &#x2F;**
   * https:&#x2F;&#x2F;webpack.docschina.org&#x2F;configuration&#x2F;optimization&#x2F;#root
   * 启用&#x2F;禁用集成优化
   *&#x2F;
  optimization?: Optimization;
  &#x2F;**
   * Options affecting the output of the compilation. &#96;output&#96; options tell webpack how to write the compiled files to disk.
   * 影响编译输出的选项. &#96;output&#96;选项告诉&#96;webpack&#96;如何将编译后的文件写入磁盘。
   *&#x2F;
  output?: Output;
  &#x2F;**
   * https:&#x2F;&#x2F;webpack.docschina.org&#x2F;configuration&#x2F;other-options&#x2F;#parallelism
   * 编译中并行处理的模块数
   * 默认 100
   *&#x2F;
  parallelism?: number; &#x2F;&#x2F;Parallelism;
  &#x2F;**
   * https:&#x2F;&#x2F;webpack.docschina.org&#x2F;configuration&#x2F;performance&#x2F;#root
   * web性能建议的配置
   *&#x2F;
  performance?: Performance;
  &#x2F;**
   * https:&#x2F;&#x2F;webpack.docschina.org&#x2F;configuration&#x2F;plugins&#x2F;#plugins
   * 向编译器添加其他插件.
   *
   * https:&#x2F;&#x2F;sourcegraph.com&#x2F;github.com&#x2F;webpack&#x2F;webpack-cli&#x2F;-&#x2F;blob&#x2F;packages&#x2F;webpack-cli&#x2F;src&#x2F;plugins&#x2F;CLIPlugin.ts?L11
   * webpack-cli 会默认在数组的最前面插入 CLIPlugin 的实例  (why ??) 主要是在控制台输出内容（打印日志）
   *&#x2F;
  plugins?: Plugins;
  &#x2F;**
   * https:&#x2F;&#x2F;webpack.docschina.org&#x2F;configuration&#x2F;other-options&#x2F;#profile
   * 捕获每个模块的计时信息
   *&#x2F;
  profile?: Profile;
  &#x2F;**
   * https:&#x2F;&#x2F;webpack.docschina.org&#x2F;configuration&#x2F;other-options&#x2F;#recordsinputpath
   * 将编译器状态存储到json文件中, 指定读取最后一条记录的文件的名称。这可以用来重命名一个记录文件
   *&#x2F;
  recordsInputPath?: string | false; &#x2F;&#x2F; RecordsInputPath;
  &#x2F;**
   * https:&#x2F;&#x2F;webpack.docschina.org&#x2F;configuration&#x2F;other-options&#x2F;#recordsoutputpath
   * 从json文件加载编译器状态
   *&#x2F;
  recordsOutputPath?: string | false; &#x2F;&#x2F; RecordsOutputPath;
  &#x2F;**
   * https:&#x2F;&#x2F;webpack.docschina.org&#x2F;configuration&#x2F;other-options&#x2F;#recordspath
   * 开启这个选项可以生成一个 JSON 文件，其中含有 webpack 的 &quot;records&quot; 记录 - 即「用于存储跨多次构建(across multiple builds)的模块标识符」的数据片段。可以使用此文件来跟踪在每次构建之间的模块变化。只要简单的设置一下路径,就可以生成这个 JSON 文件
   *&#x2F;
  recordsPath?: RecordsPath;
  &#x2F;**
   * 解析器选项
   *&#x2F;
  resolve?: Resolve;
  &#x2F;**
   * https:&#x2F;&#x2F;webpack.docschina.org&#x2F;configuration&#x2F;resolve&#x2F;#resolveloader
   * 解析loaders时解析程序的选项
   *&#x2F;
  resolveLoader?: ResolveLoader;
  &#x2F;**
   * 影响文件系统快照创建和验证方式的选
   *&#x2F;
  snapshot?: SnapshotOptions;
  &#x2F;**
   * 统计选项对象或预设名称
   * 默认: &#123;colors:false,preset:&#39;normal&#39;&#125;
   *&#x2F;
  stats?: StatsValue;
  &#x2F;**
   * 要构建的环境。尽可能为所有用户构建一系列环境
   *&#x2F;
  target?: string | false | string[]; &#x2F;&#x2F; Target;
  &#x2F;**
   * https:&#x2F;&#x2F;webpack.docschina.org&#x2F;configuration&#x2F;watch#root
   * 启用 Watch 模式，该模式将在文件更改时重建
   * Compiler 支持可以监控文件系统的 监听(watching) 机制，并且在文件修改时重新编译。
   * 当处于监听模式(watch mode)时， compiler 会触发诸如 watchRun, watchClose 和 invalid 等额外的事件
   *
   *&#x2F;
  watch?: boolean; &#x2F;&#x2F; Watch;
  &#x2F;**
   * https:&#x2F;&#x2F;webpack.docschina.org&#x2F;configuration&#x2F;watch#watchoptions
   * 一组用来定制 watch 模式的选项
   *&#x2F;
  watchOptions?: WatchOptions;
&#125;</code></pre>

<h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><pre class="language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;**
 * Custom values available in the loader context.
 *&#x2F;
export interface Loader &#123;
  [k: string]: any;
&#125;</code></pre>

<h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h2><pre class="language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;**
 * 向编译器添加其他插件
 *&#x2F;
export type Plugins &#x3D; (WebpackPluginInstance | WebpackPluginFunction)[];

&#x2F;**
 * 插件实例
 *&#x2F;
export interface WebpackPluginInstance &#123;
  &#x2F;**
   * The run point of the plugin, required method.
   *&#x2F;
  apply: (compiler: import(&quot;..&#x2F;lib&#x2F;Compiler&quot;)) &#x3D;&gt; void;
  [k: string]: any;
&#125;

&#x2F;**
 * Function acting as plugin.
 *&#x2F;
export type WebpackPluginFunction &#x3D; (
  this: import(&quot;..&#x2F;lib&#x2F;Compiler&quot;),
  compiler: import(&quot;..&#x2F;lib&#x2F;Compiler&quot;)
) &#x3D;&gt; void;</code></pre>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Tool</tag>
        <tag>Webpack5</tag>
      </tags>
  </entry>
  <entry>
    <title>tapable 使用随笔</title>
    <url>/2022/11/28/webpack/tapable/</url>
    <content><![CDATA[<h2 id="tapable"><a href="#tapable" class="headerlink" title="tapable"></a>tapable</h2><p>The <a href="https://github.com/webpack/tapable">tapable</a> package expose many Hook classes, which can be used to create hooks for plugins.</p>
<p><code>tapable</code> 是一个发布订阅模式的实现，它提供了很多应对业务的 <code>hooks</code> 实现和抽象。主要分为两大类同步和异步。</p>
<h2 id="Base-Hooks"><a href="#Base-Hooks" class="headerlink" title="Base Hooks"></a>Base Hooks</h2><ul>
<li><a href="https://sourcegraph.com/github.com/webpack/tapable/-/blob/lib/Hook.js?L25:1">Hooks</a></li>
</ul>
<p>继承 <code>Hooks</code> 的类需要自己实现<code>compile</code>抽象方法。</p>
<ul>
<li><a href="https://sourcegraph.com/github.com/webpack/tapable/-/blob/lib/HookCodeFactory.js?L7:1">HookCodeFactory</a></li>
</ul>
<p>继承<code>HookCodeFactory</code>类需要实现抽象方法<code>content</code>, 返回 <code>call</code>或<code>callAsync</code>或<code>promise</code> 的函数体的实现的代码字符串， 然后使用 <code>Function</code> 生成一个<code>call</code>或<code>callAsync</code>或<code>promise</code> 函数</p>
<h2 id="SyncHook"><a href="#SyncHook" class="headerlink" title="SyncHook"></a>SyncHook</h2><p><a href="https://sourcegraph.com/github.com/webpack/tapable/-/blob/lib/SyncHook.js?L35:1">SyncHook</a> 按注册的回调函数串行之行。</p>
<p>简单使用：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">const &#123; SyncHook &#125; &#x3D; require(&quot;tapable&quot;);
&#x2F;&#x2F; 简单来说就是实例化 Hooks 类
&#x2F;&#x2F; 接收一个可选参数，参数是一个参数名的字符串数组
&#x2F;&#x2F; 这组参数和注册回调函数的参数有关，
const hook &#x3D; new SyncHook([&quot;arg1&quot;, &quot;arg2&quot;, &quot;arg3&quot;]);
&#x2F;&#x2F; 注册
&#x2F;&#x2F; 第一个入参为注册名
&#x2F;&#x2F; 第二个为注册回调方法，参数的形参个数和&#96;SyncHook&#96;的入参的数组有关系
hook.tap(&quot;fn0&quot;, (arg1, arg2, arg3) &#x3D;&gt; &#123;
  console.log(1, arg1, arg2, arg3);
  return &quot;fn0&quot;; &#x2F;&#x2F; 回调函数的返回值之间没有联系
&#125;);
hook.tap(&quot;fn1&quot;, (arg1, arg2, arg3) &#x3D;&gt; &#123;
  console.log(2, arg1, arg2, arg3);
  return &quot;fn1&quot;;
&#125;);
hook.tap(&quot;fn2&quot;, (arg1, arg2, arg3) &#x3D;&gt; &#123;
  console.log(3, arg1, arg2, arg3);
  return &quot;fn2&quot;;
&#125;);
&#x2F;&#x2F; 执行
&#x2F;&#x2F; 执行顺序则是根据这个实例类型来决定的
hook.call(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</code></pre>

<p><code>call</code>由<a href="https://sourcegraph.com/search?q=context:global+repo:%5Egithub%5C.com/webpack/tapable$+SyncHookCodeFactory&patternType=standard&sm=1">SyncHookCodeFactory</a>的<code>content</code>实现, 结果如下：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 这是一段&#96;call&#96;方法实现的代码字符串
&#x2F;&#x2F; 这段代码需要使用 &#96;Function&#96; 来生成&#96;call&#96;方法来执行
&#x2F;&#x2F; 其中&#96;this._x&#96;就是注册的回调函数组成的数组
&#x2F;&#x2F; 可以看出回调函数的调用就是把数组中的函数展开
&quot;use strict&quot;;
var _context;
var _x &#x3D; this._x;
var _fn0 &#x3D; _x[0];
_fn0(arg3, arg2, arg1); &#x2F;&#x2F; 回调函数 fn0
var _fn1 &#x3D; _x[1];
_fn1(arg3, arg2, arg1); &#x2F;&#x2F; 回调函数 fn1
var _fn2 &#x3D; _x[2];
_fn2(arg3, arg2, arg1); &#x2F;&#x2F; 回调函数 fn2</code></pre>

<h2 id="SyncBailHook"><a href="#SyncBailHook" class="headerlink" title="SyncBailHook"></a>SyncBailHook</h2><p><a href="https://sourcegraph.com/github.com/webpack/tapable/-/blob/lib/SyncBailHook.js?L40:1">SyncBailHook</a> 会对每次执行的结果进行检测，如果结果不是 <code>undefined</code> 就直接 <code>return</code> 了，后面的回调函数就没有机会执行了。</p>
<p>简单使用：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">const &#123; SyncBailHook &#125; &#x3D; require(&quot;tapable&quot;);
&#x2F;&#x2F; 简单来说就是实例化 Hooks 类
&#x2F;&#x2F; 接收一个可选参数，参数是一个参数名的字符串数组
&#x2F;&#x2F; 这组参数和注册回调函数的参数有关，
&#x2F;&#x2F; 同步执行回调函数，回调函数返回结果不是 &#96;undefined&#96; 就直接 &#96;return&#96; 了，后面的回调函数就没有机会执行了
const hook &#x3D; new SyncBailHook([&quot;arg1&quot;, &quot;arg2&quot;, &quot;arg3&quot;]);
&#x2F;&#x2F; 注册
&#x2F;&#x2F; 第一个入参为注册名
&#x2F;&#x2F; 第二个为注册回调方法，参数的形参个数和&#96;SyncBailHook&#96;的入参的数组有关系
hook.tap(&quot;fn0&quot;, (arg1, arg2, arg3) &#x3D;&gt; &#123;
  console.log(&quot;fn0&quot;, arg1, arg2, arg3);
  return undefined;
&#125;);
hook.tap(&quot;fn1&quot;, (arg1, arg2, arg3) &#x3D;&gt; &#123;
  console.log(&quot;fn1&quot;, arg1, arg2, arg3);
  &#x2F;&#x2F; 如果回调函数的返回结果不是 &#96;undefined&#96; 就直接 &#96;return&#96; 了，后面的回调函数就没有机会执行了
  return &quot;fn1&quot;;
&#125;);
hook.tap(&quot;fn2&quot;, (arg1, arg2, arg3) &#x3D;&gt; &#123;
  console.log(&quot;fn2&quot;, arg1, arg2, arg3);
  return undefined;
&#125;);
&#x2F;&#x2F; 执行
&#x2F;&#x2F; 执行顺序则是根据这个实例类型来决定的
hook.call(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</code></pre>

<p><code>call</code>由<code>SyncBailHookCodeFactory</code>的<code>content</code>实现, 结果如下：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 这是一段&#96;call&#96;方法实现的代码字符串
&#x2F;&#x2F; 参数和SyncHook是一致的，区别在于回调函数的返回值
&#x2F;&#x2F; 如果回调函数的返回结果不是 &#96;undefined&#96; 就直接 &#96;return&#96; 了，后面的回调函数就没有机会执行了。
&#x2F;&#x2F; 就像一个有限的套娃🪆
&quot;use strict&quot;;
var _context;
var _x &#x3D; this._x;
var _fn0 &#x3D; _x[0];
var _result0 &#x3D; _fn0(arg3, arg2, arg1);
&#x2F;&#x2F; 如果返回结果不是 &#96;undefined&#96; 就直接 &#96;return&#96; 了，后面的回调函数就没有机会执行了。
if (_result0 !&#x3D;&#x3D; undefined) &#123;
  return _result0;
&#125; else &#123;
  var _fn1 &#x3D; _x[1];
  var _result1 &#x3D; _fn1(arg3, arg2, arg1);
  &#x2F;&#x2F; 如果返回结果不是 &#96;undefined&#96; 就直接 &#96;return&#96; 了，后面的回调函数就没有机会执行了。
  if (_result1 !&#x3D;&#x3D; undefined) &#123;
    return _result1;
  &#125; else &#123;
    var _fn2 &#x3D; _x[2];
    var _result2 &#x3D; _fn2(arg3, arg2, arg1);
    &#x2F;&#x2F; 如果返回结果不是 &#96;undefined&#96; 就直接 &#96;return&#96; 了，后面的回调函数就没有机会执行了。
    if (_result2 !&#x3D;&#x3D; undefined) &#123;
      return _result2;
    &#125; else &#123;
    &#125;
  &#125;
&#125;</code></pre>

<h2 id="SyncLoopHook"><a href="#SyncLoopHook" class="headerlink" title="SyncLoopHook"></a>SyncLoopHook</h2><p><a href="https://sourcegraph.com/github.com/webpack/tapable/-/blob/lib/SyncLoopHook.js?L35:1">SyncLoopHook</a> 会对每次执行的结果进行检测，如果结果不是 <code>undefined</code> 就不停循环第一个回调函数到当前回调函数，直至都返回 <code>undefined</code>。</p>
<p>简单使用：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">const &#123; SyncLoopHook &#125; &#x3D; require(&quot;tapable&quot;);
&#x2F;&#x2F; 简单来说就是实例化 Hooks 类
&#x2F;&#x2F; 接收一个可选参数，参数是一个参数名的字符串数组
&#x2F;&#x2F; 这组参数和注册回调函数的参数有关，
const hook &#x3D; new SyncLoopHook([&quot;arg1&quot;, &quot;arg2&quot;, &quot;arg3&quot;]);
let _loop &#x3D; 4;

&#x2F;&#x2F; 注册
&#x2F;&#x2F; 第一个入参为注册名
&#x2F;&#x2F; 第二个为注册回调方法，参数的形参个数和&#96;SyncLoopHook&#96;的入参的数组有关系
hook.tap(&quot;fn0&quot;, (arg1, arg2, arg3) &#x3D;&gt; &#123;
  console.log(&quot;fn0&quot;, arg1, arg2, arg3);
  return undefined;
&#125;);
hook.tap(&quot;fn1&quot;, (arg1, arg2, arg3) &#x3D;&gt; &#123;
  console.log(&quot;fn1&quot;, arg1, arg2, arg3);
  _loop &#x3D; _loop - 1;
  &#x2F;&#x2F; 如果返回结果不是 &#96;undefined&#96; 就不停循环 &#96;f0&#96; &#96;f1&#96;，直至都返回 &#96;undefined&#96;。
  return _loop &gt; 0 ? _loop : undefined;
&#125;);
hook.tap(&quot;fn2&quot;, (arg1, arg2, arg3) &#x3D;&gt; &#123;
  console.log(&quot;fn2&quot;, arg1, arg2, arg3);
  return undefined;
&#125;);
&#x2F;&#x2F; 执行
&#x2F;&#x2F; 执行顺序则是根据这个实例类型来决定的
hook.call(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</code></pre>

<p><code>call</code>由<a href="https://sourcegraph.com/github.com/webpack/tapable/-/blob/lib/SyncLoopHook.js?L10:1">SyncLoopHookCodeFactory</a>的<code>content</code>实现, 结果如下：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 这是一段&#96;call&#96;方法实现的代码字符串
&#x2F;&#x2F; 参数和SyncHook是一致的，区别在于回调函数的返回值
&#x2F;&#x2F; 如果结果不是 &#96;undefined&#96; 就不停循环第一个回调函数到当前回调函数，直至都返回 &#96;undefined&#96;
&#x2F;&#x2F; 注意: 不返回&#96;undefined&#96;就不停循环，容易造成死循环
&quot;use strict&quot;;
var _context;
var _x &#x3D; this._x;
var _loop;
do &#123;
  _loop &#x3D; false;
  var _fn0 &#x3D; _x[0];
  var _result0 &#x3D; _fn0(arg3, arg2, arg1);
  if (_result0 !&#x3D;&#x3D; undefined) &#123;
    _loop &#x3D; true;
  &#125; else &#123;
    var _fn1 &#x3D; _x[1];
    var _result1 &#x3D; _fn1(arg3, arg2, arg1);
    if (_result1 !&#x3D;&#x3D; undefined) &#123;
      _loop &#x3D; true;
    &#125; else &#123;
      var _fn2 &#x3D; _x[2];
      var _result2 &#x3D; _fn2(arg3, arg2, arg1);
      if (_result2 !&#x3D;&#x3D; undefined) &#123;
        _loop &#x3D; true;
      &#125; else &#123;
        if (!_loop) &#123;
        &#125;
      &#125;
    &#125;
  &#125;
&#125; while (_loop);</code></pre>

<h2 id="SyncWaterfallHook"><a href="#SyncWaterfallHook" class="headerlink" title="SyncWaterfallHook"></a>SyncWaterfallHook</h2><p><a href="https://sourcegraph.com/github.com/webpack/tapable/-/blob/lib/SyncWaterfallHook.js?L44">SyncWaterfallHook</a> 会对每次执行的结果当成下一个回调函数的入参（<code>call</code>的入参 ），如果返回值是 <code>undefined</code>，使用上一个参数。</p>
<p>简单使用：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">const &#123; SyncWaterfallHook &#125; &#x3D; require(&quot;tapable&quot;);
&#x2F;&#x2F; 简单来说就是实例化 Hooks 类
&#x2F;&#x2F; 接收一个可选参数，参数是一个参数名的字符串数组
&#x2F;&#x2F; 这组参数和注册回调函数的参数有关，
const hook &#x3D; new SyncWaterfallHook([&quot;arg1&quot;, &quot;arg2&quot;, &quot;arg3&quot;]);

&#x2F;&#x2F; 注册
&#x2F;&#x2F; 第一个入参为注册名
&#x2F;&#x2F; 第二个为注册回调方法，参数的形参个数和&#96;SyncWaterfallHook&#96;的入参的数组有关系
hook.tap(&quot;fn0&quot;, (arg1, arg2, arg3) &#x3D;&gt; &#123;
  console.log(&quot;fn0&quot;, arg1, arg2, arg3);
  return &quot;fn0-result&quot;;
&#125;);
hook.tap(&quot;fn1&quot;, (arg1, arg2, arg3) &#x3D;&gt; &#123;
  console.log(&quot;fn1&quot;, arg1, arg2, arg3);
  return undefined;
&#125;);
hook.tap(&quot;fn2&quot;, (arg1, arg2, arg3) &#x3D;&gt; &#123;
  console.log(&quot;fn2&quot;, arg1, arg2, arg3);
  return &quot;fn2&quot;;
&#125;);
hook.tap(&quot;fn3&quot;, (arg1, arg2, arg3) &#x3D;&gt; &#123;
  console.log(&quot;fn3&quot;, arg1, arg2, arg3);
  return &quot;fn3&quot;;
&#125;);
&#x2F;&#x2F; 执行
&#x2F;&#x2F; 执行顺序则是根据这个实例类型来决定的
hook.call(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
&#x2F;&#x2F; 执行结果：
&#x2F;&#x2F; fn0 a b c
&#x2F;&#x2F; fn1 fn0-result b c
&#x2F;&#x2F; fn2 fn0-result b c
&#x2F;&#x2F; fn3 fn2 b c</code></pre>

<p><code>call</code>由<a href="https://sourcegraph.com/github.com/webpack/tapable/-/blob/lib/SyncWaterfallHook.js?L10:7">SyncWaterfallHookCodeFactory</a>的<code>content</code>实现, 结果如下：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 这是一段&#96;call&#96;方法实现的代码字符串
&#x2F;&#x2F; 参数和SyncHook是一致的，区别在于回调函数的返回值
&#x2F;&#x2F; 如果返回值是 &#96;undefined&#96; , 使用&#96;call&#96;的参数，否则使用返回的值
&quot;use strict&quot;;
var _context;
var _x &#x3D; this._x;
var _fn0 &#x3D; _x[0];
var _result0 &#x3D; _fn0(arg1, arg2, arg3);
if (_result0 !&#x3D;&#x3D; undefined) &#123;
  &#x2F;&#x2F; 如果返回值是 &#96;undefined&#96; , 使用&#96;call&#96;的参数，否则使用返回的值
  arg1 &#x3D; _result0;
&#125;
var _fn1 &#x3D; _x[1];
var _result1 &#x3D; _fn1(arg1, arg2, arg3);
if (_result1 !&#x3D;&#x3D; undefined) &#123;
  &#x2F;&#x2F; 如果返回值是 &#96;undefined&#96; , 使用&#96;call&#96;的参数，否则使用返回的值
  arg1 &#x3D; _result1;
&#125;
var _fn2 &#x3D; _x[2];
var _result2 &#x3D; _fn2(arg1, arg2, arg3);
if (_result2 !&#x3D;&#x3D; undefined) &#123;
  &#x2F;&#x2F; 如果返回值是 &#96;undefined&#96; , 使用&#96;call&#96;的参数，否则使用返回的值
  arg1 &#x3D; _result2;
&#125;
var _fn3 &#x3D; _x[3];
var _result3 &#x3D; _fn3(arg1, arg2, arg3);
if (_result3 !&#x3D;&#x3D; undefined) &#123;
  arg1 &#x3D; _result3;
&#125;
return arg1;</code></pre>

<h2 id="AsyncSeriesHook"><a href="#AsyncSeriesHook" class="headerlink" title="AsyncSeriesHook"></a>AsyncSeriesHook</h2><p><a href="https://sourcegraph.com/github.com/webpack/tapable/-/blob/lib/AsyncSeriesHook.js?L26:1">AsyncSeriesHook</a>异步串行</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">const &#123; AsyncSeriesHook &#125; &#x3D; require(&quot;tapable&quot;);
&#x2F;&#x2F; 简单来说就是实例化 Hooks 类
&#x2F;&#x2F; 接收一个可选参数，参数是一个参数名的字符串数组
&#x2F;&#x2F; 这组参数和注册回调函数的参数有关，
const hook &#x3D; new AsyncSeriesHook([&quot;arg1&quot;, &quot;arg2&quot;, &quot;arg3&quot;]);

&#x2F;&#x2F; 注册
&#x2F;&#x2F; 第一个入参为注册名
&#x2F;&#x2F; 第二个为注册回调方法，参数的形参个数和&#96;AsyncSeriesHook&#96;的入参的数组有关系
hook.tapAsync(&quot;fn0&quot;, (arg1, arg2, arg3, callback) &#x3D;&gt; &#123;
  setTimeout(() &#x3D;&gt; &#123;
    console.log(&quot;fn0&quot;, arg1, arg2, arg3);
    callback();
  &#125;, 1000);
&#125;);
hook.tapAsync(&quot;fn1&quot;, (arg1, arg2, arg3, callback) &#x3D;&gt; &#123;
  setTimeout(() &#x3D;&gt; &#123;
    console.log(&quot;fn1&quot;, arg1, arg2, arg3);
    callback();
  &#125;, 1000);
&#125;);
hook.tapAsync(&quot;fn2&quot;, (arg1, arg2, arg3, callback) &#x3D;&gt; &#123;
  setTimeout(() &#x3D;&gt; &#123;
    console.log(&quot;fn2&quot;, arg1, arg2, arg3);
    callback(); &#x2F;&#x2F; 决定 &#96;callAsync&#96; 最后的实参callback是否会被调用
  &#125;, 1000);
&#125;);
&#x2F;&#x2F; 执行
&#x2F;&#x2F; 执行顺序则是根据这个实例类型来决定的
hook.callAsync(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, () &#x3D;&gt; &#123;
  console.log(&quot;AsyncSeriesHook async&quot;);
&#125;);

&#x2F;&#x2F; 执行结果：
&#x2F;&#x2F; fn0 a b c
&#x2F;&#x2F; fn1 a b c
&#x2F;&#x2F; fn2 a b c
&#x2F;&#x2F; AsyncSeriesHook async</code></pre>

<p><code>callAsync</code> 由<a href="https://sourcegraph.com/github.com/webpack/tapable/-/blob/lib/AsyncSeriesHook.js?L10:1">AsyncSeriesHookCodeFactory</a>的<code>content</code>实现, 更深层次来说应该是由<a href="https://sourcegraph.com/github.com/webpack/tapable/-/blob/lib/HookCodeFactory.js?L7:1">HookCodeFactory</a>的<a href="https://sourcegraph.com/github.com/webpack/tapable/-/blob/lib/HookCodeFactory.js?L276">callTapsSeries</a>实现。 结果如下：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">&quot;use strict&quot;;
var _context;
var _x &#x3D; this._x;
function _next1() &#123;
  var _fn2 &#x3D; _x[2];
  _fn2(arg1, arg2, arg3, function (_err2) &#123;
    &#x2F;&#x2F; ...
  &#125;);
&#125;
function _next0() &#123;
  var _fn1 &#x3D; _x[1];
  _fn1(arg1, arg2, arg3, function (_err1) &#123;
    &#x2F;&#x2F; ...
    _next1();
  &#125;);
&#125;
var _fn0 &#x3D; _x[0];
_fn0(arg1, arg2, arg3, function (_err0) &#123;
  &#x2F;&#x2F; ...
  _next0();
&#125;);</code></pre>

<p><code>Promise</code> 方式</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">const &#123; AsyncSeriesHook &#125; &#x3D; require(&quot;tapable&quot;);

&#x2F;&#x2F; 简单来说就是实例化 Hooks 类
&#x2F;&#x2F; 接收一个可选参数，参数是一个参数名的字符串数组
&#x2F;&#x2F; 这组参数和注册回调函数的参数有关，
const hook &#x3D; new AsyncSeriesHook([&quot;arg1&quot;, &quot;arg2&quot;, &quot;arg3&quot;]);

&#x2F;&#x2F; 注册
&#x2F;&#x2F; 第一个入参为注册名
&#x2F;&#x2F; 第二个为注册回调方法，参数的形参个数和&#96;AsyncSeriesHook&#96;的入参的数组有关系
hook.tapPromise(&quot;fn0&quot;, (arg1, arg2, arg3) &#x3D;&gt; &#123;
  return new Promise((resolve, reject) &#x3D;&gt; &#123;
    setTimeout(() &#x3D;&gt; &#123;
      console.log(&quot;fn0&quot;, arg1, arg2, arg3);
      resolve();
    &#125;, 1000);
  &#125;);
&#125;);
hook.tapPromise(&quot;fn1&quot;, (arg1, arg2, arg3, callback) &#x3D;&gt; &#123;
  return new Promise((resolve, reject) &#x3D;&gt; &#123;
    setTimeout(() &#x3D;&gt; &#123;
      console.log(&quot;fn1&quot;, arg1, arg2, arg3);
      resolve();
    &#125;, 1000);
  &#125;);
&#125;);
hook.tapPromise(&quot;fn2&quot;, (arg1, arg2, arg3, callback) &#x3D;&gt; &#123;
  return new Promise((resolve, reject) &#x3D;&gt; &#123;
    setTimeout(() &#x3D;&gt; &#123;
      console.log(&quot;fn2&quot;, arg1, arg2, arg3);
      resolve();
    &#125;, 1000);
  &#125;);
&#125;);
&#x2F;&#x2F; 执行
&#x2F;&#x2F; 执行顺序则是根据这个实例类型来决定的
hook.promise(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</code></pre>

<p><code>promise</code> 由<a href="https://sourcegraph.com/github.com/webpack/tapable/-/blob/lib/AsyncSeriesHook.js?L10:1">AsyncSeriesHookCodeFactory</a>的<code>content</code>实现, 更深层次来说应该是由<a href="https://sourcegraph.com/github.com/webpack/tapable/-/blob/lib/HookCodeFactory.js?L7:1">HookCodeFactory</a>的<a href="https://sourcegraph.com/github.com/webpack/tapable/-/blob/lib/HookCodeFactory.js?L276">callTapsSeries</a>实现。 结果如下：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">&quot;use strict&quot;;
var _context;
var _x &#x3D; this._x;
function _next1() &#123;
  var _fn2 &#x3D; _x[2];
  var _hasResult2 &#x3D; false;
  var _promise2 &#x3D; _fn2(arg1, arg2, arg3);
  _promise2.then(function (_result2) &#123;
    _hasResult2 &#x3D; true;
  &#125;);
&#125;
function _next0() &#123;
  var _fn1 &#x3D; _x[1];
  var _hasResult1 &#x3D; false;
  var _promise1 &#x3D; _fn1(arg1, arg2, arg3);
  _promise1.then(function (_result1) &#123;
    _hasResult1 &#x3D; true;
    _next1();
  &#125;);
&#125;
var _fn0 &#x3D; _x[0];
var _hasResult0 &#x3D; false;
var _promise0 &#x3D; _fn0(arg1, arg2, arg3);
_promise0.then(function (_result0) &#123;
  _hasResult0 &#x3D; true;
  _next0();
&#125;);</code></pre>

<h2 id="AsyncSeriesBailHook"><a href="#AsyncSeriesBailHook" class="headerlink" title="AsyncSeriesBailHook"></a>AsyncSeriesBailHook</h2><p><a href="https://sourcegraph.com/github.com/webpack/tapable/-/blob/lib/AsyncSeriesBailHook.js?L31">AsyncSeriesBailHook</a> 会对每次异步执行的结果进行检测，如果结果不是 <code>undefined</code> 就直接 <code>return</code> 了，后面的回调函数就没有机会执行了</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">const &#123; AsyncSeriesBailHook &#125; &#x3D; require(&quot;tapable&quot;);
&#x2F;&#x2F; 简单来说就是实例化 Hooks 类
&#x2F;&#x2F; 接收一个可选参数，参数是一个参数名的字符串数组
&#x2F;&#x2F; 这组参数和注册回调函数的参数有关，
const hook &#x3D; new AsyncSeriesBailHook([&quot;arg1&quot;, &quot;arg2&quot;, &quot;arg3&quot;]);

&#x2F;&#x2F; 注册
&#x2F;&#x2F; 第一个入参为注册名
&#x2F;&#x2F; 第二个为注册回调方法，参数的形参个数和&#96;AsyncSeriesBailHook&#96;的入参的数组有关系
&#x2F;&#x2F; 串行调用
hook.tapPromise(&quot;fn0&quot;, (arg1, arg2, arg3) &#x3D;&gt; &#123;
  return new Promise((resolve, reject) &#x3D;&gt; &#123;
    setTimeout(() &#x3D;&gt; &#123;
      console.log(&quot;fn0&quot;, arg1, arg2, arg3);
      resolve();
    &#125;, 1000);
  &#125;);
&#125;);
hook.tapPromise(&quot;fn1&quot;, (arg1, arg2, arg3, callback) &#x3D;&gt; &#123;
  return new Promise((resolve, reject) &#x3D;&gt; &#123;
    setTimeout(() &#x3D;&gt; &#123;
      console.log(&quot;fn1&quot;, arg1, arg2, arg3);
      resolve(12); &#x2F;&#x2F; 后面的回调不会执行
    &#125;, 1000);
  &#125;);
&#125;);
hook.tapPromise(&quot;fn2&quot;, (arg1, arg2, arg3, callback) &#x3D;&gt; &#123;
  return new Promise((resolve, reject) &#x3D;&gt; &#123;
    setTimeout(() &#x3D;&gt; &#123;
      console.log(&quot;fn2&quot;, arg1, arg2, arg3);
      resolve();
    &#125;, 1000);
  &#125;);
&#125;);
&#x2F;&#x2F; 执行
&#x2F;&#x2F; 执行顺序则是根据这个实例类型来决定的
hook.promise(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);

&#x2F;&#x2F; 执行结果：
&#x2F;&#x2F; fn0 a b c
&#x2F;&#x2F; fn1 a b c</code></pre>

<p><code>tapAsync</code> 和 <code>callAsync</code>的组合同理</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">&quot;use strict&quot;;
var _context;
var _x &#x3D; this._x;
function _next1() &#123;
  var _fn2 &#x3D; _x[2];
  var _hasResult2 &#x3D; false;
  var _promise2 &#x3D; _fn2(arg1, arg2, arg3);
  &#x2F;&#x2F;...
  _promise2.then(function (_result2) &#123;
    _hasResult2 &#x3D; true;
    if (_result2 !&#x3D;&#x3D; undefined) &#123;
      return _result2;
    &#125; else &#123;
    &#125;
  &#125;);
&#125;
function _next0() &#123;
  var _fn1 &#x3D; _x[1];
  var _hasResult1 &#x3D; false;
  var _promise1 &#x3D; _fn1(arg1, arg2, arg3);
  &#x2F;&#x2F;...
  _promise1.then(
    function (_result1) &#123;
      _hasResult1 &#x3D; true;
      if (_result1 !&#x3D;&#x3D; undefined) &#123;
        return _result1;
      &#125; else &#123;
        return _next1();
      &#125;
    &#125;
    &#x2F;&#x2F;...
  );
&#125;
var _fn0 &#x3D; _x[0];
var _hasResult0 &#x3D; false;
var _promise0 &#x3D; _fn0(arg1, arg2, arg3);
&#x2F;&#x2F;...
_promise0.then(
  function (_result0) &#123;
    _hasResult0 &#x3D; true;
    if (_result0 !&#x3D;&#x3D; undefined) &#123;
      return _result0;
    &#125; else &#123;
      return _next0();
    &#125;
  &#125;
  &#x2F;&#x2F;...
);</code></pre>

<h2 id="AsyncSeriesLoopHook"><a href="#AsyncSeriesLoopHook" class="headerlink" title="AsyncSeriesLoopHook"></a>AsyncSeriesLoopHook</h2><p><a href="https://sourcegraph.com/github.com/webpack/tapable/-/blob/lib/AsyncSeriesLoopHook.js?L26">AsyncSeriesLoopHook</a>会对每次异步执行的结果进行检测，如果结果不是 <code>undefined</code> 就不停循环第一个回调函数到当前回调函数，直至都返回 <code>undefined</code>。</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">const &#123; AsyncSeriesLoopHook &#125; &#x3D; require(&quot;tapable&quot;);
&#x2F;&#x2F; 简单来说就是实例化 Hooks 类
&#x2F;&#x2F; 接收一个可选参数，参数是一个参数名的字符串数组
&#x2F;&#x2F; 这组参数和注册回调函数的参数有关，
const hook &#x3D; new AsyncSeriesLoopHook([&quot;arg1&quot;, &quot;arg2&quot;, &quot;arg3&quot;]);

let _loop &#x3D; 2; &#x2F;&#x2F; 循环两次

&#x2F;&#x2F; 注册
&#x2F;&#x2F; 第一个入参为注册名
&#x2F;&#x2F; 第二个为注册回调方法，参数的形参个数和&#96;AsyncSeriesLoopHook&#96;的入参的数组有关系
hook.tapPromise(&quot;fn0&quot;, (arg1, arg2, arg3) &#x3D;&gt; &#123;
  return new Promise((resolve, reject) &#x3D;&gt; &#123;
    setTimeout(() &#x3D;&gt; &#123;
      console.log(&quot;fn0&quot;, arg1, arg2, arg3);
      resolve();
    &#125;, 1000);
  &#125;);
&#125;);
hook.tapPromise(&quot;fn1&quot;, (arg1, arg2, arg3, callback) &#x3D;&gt; &#123;
  return new Promise((resolve, reject) &#x3D;&gt; &#123;
    setTimeout(() &#x3D;&gt; &#123;
      console.log(&quot;fn1&quot;, arg1, arg2, arg3);
      resolve(_loop &gt; 0 ? &quot;fn1 result&quot; : undefined);
      _loop &#x3D; _loop - 1;
    &#125;, 1000);
  &#125;);
&#125;);
hook.tapPromise(&quot;fn2&quot;, (arg1, arg2, arg3, callback) &#x3D;&gt; &#123;
  return new Promise((resolve, reject) &#x3D;&gt; &#123;
    setTimeout(() &#x3D;&gt; &#123;
      console.log(&quot;fn2&quot;, arg1, arg2, arg3);
      resolve();
    &#125;, 1000);
  &#125;);
&#125;);
&#x2F;&#x2F; 执行
&#x2F;&#x2F; 执行顺序则是根据这个实例类型来决定的
hook.promise(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);

&#x2F;&#x2F; 执行结果
&#x2F;&#x2F; fn0 a b c
&#x2F;&#x2F; fn1 a b c
&#x2F;&#x2F; fn0 a b c &#x2F;&#x2F; 循环
&#x2F;&#x2F; fn1 a b c &#x2F;&#x2F; 循环
&#x2F;&#x2F; fn0 a b c &#x2F;&#x2F; 循环
&#x2F;&#x2F; fn1 a b c &#x2F;&#x2F; 循环
&#x2F;&#x2F; fn2 a b c</code></pre>

<p><code>tapAsync</code> 和 <code>callAsync</code>的组合同理</p>
<p><code>promise</code> 由<a href="https://sourcegraph.com/github.com/webpack/tapable/-/blob/lib/AsyncSeriesLoopHook.js?L10:1">AsyncSeriesLoopHookCodeFactory</a>的<code>content</code>实现, 更深层次来说应该是由<a href="https://sourcegraph.com/github.com/webpack/tapable/-/blob/lib/HookCodeFactory.js?L7:1">HookCodeFactory</a>的<a href="https://sourcegraph.com/github.com/webpack/tapable/-/blob/lib/HookCodeFactory.js?L324:2">callTapsLooping</a>实现。 结果如下：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">&quot;use strict&quot;;
var _context;
var _x &#x3D; this._x;
var _looper &#x3D; function () &#123;
  var _loopAsync &#x3D; false;
  var _loop;
  do &#123;
    _loop &#x3D; false;
    function _next1() &#123;
      var _fn2 &#x3D; _x[2];
      var _hasResult2 &#x3D; false;
      var _promise2 &#x3D; _fn2(arg1, arg2, arg3);
      &#x2F;&#x2F; 判断返回是不是promise
      if (!_promise2 || !_promise2.then)
        throw new Error(
          &quot;Tap function (tapPromise) did not return promise (returned &quot; +
            _promise2 +
            &quot;)&quot;
        );
      _promise2.then(
        function (_result2) &#123;
          _hasResult2 &#x3D; true;
          if (_result2 !&#x3D;&#x3D; undefined) &#123;
            _loop &#x3D; true;
            if (_loopAsync) _looper();
          &#125; else &#123;
            if (!_loop) &#123;
            &#125;
          &#125;
        &#125;
        &#x2F;&#x2F; ... reject 处理
      );
    &#125;
    function _next0() &#123;
      var _fn1 &#x3D; _x[1];
      var _hasResult1 &#x3D; false;
      var _promise1 &#x3D; _fn1(arg1, arg2, arg3);
      &#x2F;&#x2F; ...
      _promise1.then(
        function (_result1) &#123;
          _hasResult1 &#x3D; true;
          if (_result1 !&#x3D;&#x3D; undefined) &#123;
            _loop &#x3D; true;
            if (_loopAsync) _looper();
          &#125; else &#123;
            _next1();
          &#125;
        &#125;
        &#x2F;&#x2F; ... reject 处理
      );
    &#125;
    var _fn0 &#x3D; _x[0];
    var _hasResult0 &#x3D; false;
    var _promise0 &#x3D; _fn0(arg1, arg2, arg3);
    &#x2F;&#x2F; ...
    _promise0.then(
      function (_result0) &#123;
        _hasResult0 &#x3D; true;
        if (_result0 !&#x3D;&#x3D; undefined) &#123;
          _loop &#x3D; true;
          if (_loopAsync) _looper();
        &#125; else &#123;
          _next0();
        &#125;
      &#125;
      &#x2F;&#x2F; ... reject 处理
    );
  &#125; while (_loop);
  _loopAsync &#x3D; true;
&#125;;
_looper();</code></pre>

<h2 id="AsyncSeriesWaterfallHook"><a href="#AsyncSeriesWaterfallHook" class="headerlink" title="AsyncSeriesWaterfallHook"></a>AsyncSeriesWaterfallHook</h2><p><a href="https://sourcegraph.com/github.com/webpack/tapable/-/blob/lib/AsyncSeriesWaterfallHook.js?L34">AsyncSeriesWaterfallHook</a>会对每次执行异步函数的结果当成下一个回调函数的入参（<code>callAsync</code>&#x2F;<code>promise</code>的入参 ），如果返回值是 <code>undefined</code>，使用上一个参数。</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">const &#123; AsyncSeriesWaterfallHook &#125; &#x3D; require(&quot;tapable&quot;);
&#x2F;&#x2F; 简单来说就是实例化 Hooks 类
&#x2F;&#x2F; 接收一个可选参数，参数是一个参数名的字符串数组
&#x2F;&#x2F; 这组参数和注册回调函数的参数有关，
const hook &#x3D; new AsyncSeriesWaterfallHook([&quot;arg1&quot;, &quot;arg2&quot;, &quot;arg3&quot;]);

&#x2F;&#x2F; 注册
&#x2F;&#x2F; 第一个入参为注册名
&#x2F;&#x2F; 第二个为注册回调方法，参数的形参个数和&#96;AsyncSeriesWaterfallHook&#96;的入参的数组有关系
hook.tapPromise(&quot;fn0&quot;, (arg1, arg2, arg3) &#x3D;&gt; &#123;
  return new Promise((resolve, reject) &#x3D;&gt; &#123;
    setTimeout(() &#x3D;&gt; &#123;
      console.log(&quot;fn0&quot;, arg1, arg2, arg3);
      resolve();
    &#125;, 1000);
  &#125;);
&#125;);
hook.tapPromise(&quot;fn1&quot;, (arg1, arg2, arg3, callback) &#x3D;&gt; &#123;
  return new Promise((resolve, reject) &#x3D;&gt; &#123;
    setTimeout(() &#x3D;&gt; &#123;
      console.log(&quot;fn1&quot;, arg1, arg2, arg3);
      resolve(&quot;fn1-result&quot;); &#x2F;&#x2F; 返回值作为fn2的第一个入参
    &#125;, 1000);
  &#125;);
&#125;);
hook.tapPromise(&quot;fn2&quot;, (arg1, arg2, arg3, callback) &#x3D;&gt; &#123;
  return new Promise((resolve, reject) &#x3D;&gt; &#123;
    setTimeout(() &#x3D;&gt; &#123;
      console.log(&quot;fn2&quot;, arg1, arg2, arg3);
      resolve();
    &#125;, 1000);
  &#125;);
&#125;);
&#x2F;&#x2F; 执行
&#x2F;&#x2F; 执行顺序则是根据这个实例类型来决定的
hook.promise(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);

&#x2F;&#x2F; 执行结果
&#x2F;&#x2F; fn0 a b c
&#x2F;&#x2F; fn1 a b c
&#x2F;&#x2F; fn2 fn1-result b c</code></pre>

<p><code>tapAsync</code> 和 <code>callAsync</code>的组合同理</p>
<p><code>promise</code> 由<a href="https://sourcegraph.com/github.com/webpack/tapable/-/blob/lib/AsyncSeriesWaterfallHook.js?L10:1">AsyncSeriesWaterfallHookCodeFactory</a>的<code>content</code>实现, 更深层次来说应该是由<a href="https://sourcegraph.com/github.com/webpack/tapable/-/blob/lib/HookCodeFactory.js?L7:1">HookCodeFactory</a>的<a href="https://sourcegraph.com/github.com/webpack/tapable/-/blob/lib/HookCodeFactory.js?L276">callTapsSeries</a>实现。 结果如下：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">&quot;use strict&quot;;
var _context;
var _x &#x3D; this._x;
function _next2() &#123;
  var _fn3 &#x3D; _x[3];
  var _hasResult3 &#x3D; false;
  var _promise3 &#x3D; _fn3(arg1, arg2, arg3);
  if (!_promise3 || !_promise3.then)
    &#x2F;&#x2F; 判断返回是不是promise
    throw new Error(
      &quot;Tap function (tapPromise) did not return promise (returned &quot; +
        _promise3 +
        &quot;)&quot;
    );
  _promise3.then(
    function (_result3) &#123;
      _hasResult3 &#x3D; true;
      if (_result3 !&#x3D;&#x3D; undefined) &#123;
        arg1 &#x3D; _result3;
      &#125;
      return arg1;
    &#125;
    &#x2F;&#x2F; ...
  );
&#125;
function _next1() &#123;
  var _fn2 &#x3D; _x[2];
  var _hasResult2 &#x3D; false;
  var _promise2 &#x3D; _fn2(arg1, arg2, arg3);
  &#x2F;&#x2F; ...
  _promise2.then(function (_result2) &#123;
    _hasResult2 &#x3D; true;
    if (_result2 !&#x3D;&#x3D; undefined) &#123;
      arg1 &#x3D; _result2;
    &#125;
    _next2();
  &#125;);
&#125;
function _next0() &#123;
  var _fn1 &#x3D; _x[1];
  var _hasResult1 &#x3D; false;
  var _promise1 &#x3D; _fn1(arg1, arg2, arg3);
  &#x2F;&#x2F; ...
  _promise1.then(
    function (_result1) &#123;
      _hasResult1 &#x3D; true;
      if (_result1 !&#x3D;&#x3D; undefined) &#123;
        arg1 &#x3D; _result1;
      &#125;
      _next1();
    &#125;
    &#x2F;&#x2F; ...
  );
&#125;
var _fn0 &#x3D; _x[0];
var _hasResult0 &#x3D; false;
var _promise0 &#x3D; _fn0(arg1, arg2, arg3);
&#x2F;&#x2F; ...
_promise0.then(
  function (_result0) &#123;
    _hasResult0 &#x3D; true;
    if (_result0 !&#x3D;&#x3D; undefined) &#123;
      arg1 &#x3D; _result0;
    &#125;
    _next0();
  &#125;
  &#x2F;&#x2F; ...
);</code></pre>

<h2 id="AsyncParallelHook"><a href="#AsyncParallelHook" class="headerlink" title="AsyncParallelHook"></a>AsyncParallelHook</h2><p><a href="https://sourcegraph.com/github.com/webpack/tapable/-/blob/lib/AsyncParallelHook.js?L26:1">AsyncParallelHook</a>并行执行, 不关心回调函数的返回值。</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">const &#123; AsyncParallelHook &#125; &#x3D; require(&quot;tapable&quot;);
&#x2F;&#x2F; 简单来说就是实例化 Hooks 类
&#x2F;&#x2F; 接收一个可选参数，参数是一个参数名的字符串数组
&#x2F;&#x2F; 这组参数和注册回调函数的参数有关，
&#x2F;&#x2F; 并行执行 不关心回调函数的返回值。
const hook &#x3D; new AsyncParallelHook([&quot;arg1&quot;, &quot;arg2&quot;, &quot;arg3&quot;]);

&#x2F;&#x2F; 注册
&#x2F;&#x2F; 第一个入参为注册名
&#x2F;&#x2F; 第二个为注册回调方法，参数的形参个数和&#96;AsyncParallelHook&#96;的入参的数组有关系
hook.tapPromise(&quot;fn0&quot;, (arg1, arg2, arg3) &#x3D;&gt; &#123;
  return new Promise((resolve, reject) &#x3D;&gt; &#123;
    setTimeout(() &#x3D;&gt; &#123;
      console.log(&quot;fn0&quot;, arg1, arg2, arg3);
      resolve();
    &#125;, 1000);
  &#125;);
&#125;);
hook.tapPromise(&quot;fn1&quot;, (arg1, arg2, arg3) &#x3D;&gt; &#123;
  return new Promise((resolve, reject) &#x3D;&gt; &#123;
    setTimeout(() &#x3D;&gt; &#123;
      console.log(&quot;fn1&quot;, arg1, arg2, arg3);
      resolve(&quot;fn1-result&quot;);
    &#125;, 1000);
  &#125;);
&#125;);
hook.tapPromise(&quot;fn2&quot;, (arg1, arg2, arg3) &#x3D;&gt; &#123;
  return new Promise((resolve, reject) &#x3D;&gt; &#123;
    setTimeout(() &#x3D;&gt; &#123;
      console.log(&quot;fn2&quot;, arg1, arg2, arg3);
      resolve();
    &#125;, 500);
  &#125;);
&#125;);
&#x2F;&#x2F; 执行
&#x2F;&#x2F; 执行顺序则是根据这个实例类型来决定的
hook.promise(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);

&#x2F;&#x2F; 执行结果
&#x2F;&#x2F; fn2 a b c
&#x2F;&#x2F; fn0 a b c
&#x2F;&#x2F; fn1 a b c</code></pre>

<p><code>tapAsync</code> 和 <code>callAsync</code>的组合同理</p>
<p><code>promise</code> 由<a href="https://sourcegraph.com/github.com/webpack/tapable/-/blob/lib/AsyncParallelHook.js?L10:1">AsyncParallelHookCodeFactory</a>的<code>content</code>实现, 更深层次来说应该是由<a href="https://sourcegraph.com/github.com/webpack/tapable/-/blob/lib/HookCodeFactory.js?L7:1">HookCodeFactory</a>的<a href="https://sourcegraph.com/github.com/webpack/tapable/-/blob/lib/HookCodeFactory.js?L376:2">callTapsParallel</a>实现。 结果如下：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">&quot;use strict&quot;;
var _context;
var _x &#x3D; this._x;
do &#123;
  var _counter &#x3D; 3;
  var _done &#x3D; function () &#123;&#125;;
  if (_counter &lt;&#x3D; 0) break;
  var _fn0 &#x3D; _x[0];
  var _hasResult0 &#x3D; false;
  var _promise0 &#x3D; _fn0(arg1, arg2, arg3);

  &#x2F;&#x2F; 判断返回是不是promise
  if (!_promise0 || !_promise0.then)
    throw new Error(
      &quot;Tap function (tapPromise) did not return promise (returned &quot; +
        _promise0 +
        &quot;)&quot;
    );
  _promise0.then(
    function (_result0) &#123;
      _hasResult0 &#x3D; true;
      if (--_counter &#x3D;&#x3D;&#x3D; 0) _done();
    &#125;,
    function (_err0) &#123;
      if (_hasResult0) throw _err0;
      if (_counter &gt; 0) &#123;
        throw _err0;
        _counter &#x3D; 0;
      &#125;
    &#125;
  );
  if (_counter &lt;&#x3D; 0) break;
  var _fn1 &#x3D; _x[1];
  var _hasResult1 &#x3D; false;
  var _promise1 &#x3D; _fn1(arg1, arg2, arg3);
  &#x2F;&#x2F; ...
  _promise1.then(
    function (_result1) &#123;
      _hasResult1 &#x3D; true;
      if (--_counter &#x3D;&#x3D;&#x3D; 0) _done();
    &#125;,
    function (_err1) &#123;
      if (_hasResult1) throw _err1;
      if (_counter &gt; 0) &#123;
        throw _err1;
        _counter &#x3D; 0;
      &#125;
    &#125;
  );
  if (_counter &lt;&#x3D; 0) break;
  var _fn2 &#x3D; _x[2];
  var _hasResult2 &#x3D; false;
  var _promise2 &#x3D; _fn2(arg1, arg2, arg3);
  &#x2F;&#x2F; ...
  _promise2.then(
    function (_result2) &#123;
      _hasResult2 &#x3D; true;
      if (--_counter &#x3D;&#x3D;&#x3D; 0) _done();
    &#125;,
    function (_err2) &#123;
      if (_hasResult2) throw _err2;
      if (_counter &gt; 0) &#123;
        throw _err2;
        _counter &#x3D; 0;
      &#125;
    &#125;
  );
&#125; while (false);</code></pre>

<h2 id="AsyncParallelBailHook"><a href="#AsyncParallelBailHook" class="headerlink" title="AsyncParallelBailHook"></a>AsyncParallelBailHook</h2><p><a href="https://sourcegraph.com/github.com/webpack/tapable/-/blob/lib/AsyncParallelBailHook.js?L74:1">AsyncParallelBailHook</a> 只要回调函数的返回值不为 <code>undefined</code>, 就会忽略后面的回调函数执行, 直接跳跃到 <code>callAsync</code> 等触发函数绑定的回调函数, 然后执行这个被绑定的回调函数。</p>
<p>使用和原理与 SyncBailHook 相似</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">const &#123; AsyncParallelBailHook &#125; &#x3D; require(&quot;tabable&quot;);
&#x2F;&#x2F; 简单来说就是实例化 Hooks 类
&#x2F;&#x2F; 接收一个可选参数，参数是一个参数名的字符串数组
&#x2F;&#x2F; 这组参数和注册回调函数的参数有关，
&#x2F;&#x2F; 并行执行 不关心回调函数的返回值。
const hook &#x3D; new AsyncParallelBailHook([&quot;arg1&quot;, &quot;arg2&quot;, &quot;arg3&quot;]);

&#x2F;&#x2F; 注册
&#x2F;&#x2F; 第一个入参为注册名
&#x2F;&#x2F; 第二个为注册回调方法，参数的形参个数和&#96;AsyncParallelBailHook&#96;的入参的数组有关系
hook.tapPromise(&quot;fn0&quot;, (arg1, arg2, arg3) &#x3D;&gt; &#123;
  return new Promise((resolve, reject) &#x3D;&gt; &#123;
    setTimeout(() &#x3D;&gt; &#123;
      console.log(&quot;fn0&quot;, arg1, arg2, arg3);
      resolve();
    &#125;, 1000);
  &#125;);
&#125;);
hook.tapPromise(&quot;fn1&quot;, (arg1, arg2, arg3) &#x3D;&gt; &#123;
  return new Promise((resolve, reject) &#x3D;&gt; &#123;
    setTimeout(() &#x3D;&gt; &#123;
      console.log(&quot;fn1&quot;, arg1, arg2, arg3);
      resolve(&quot;fn1-result&quot;);
    &#125;, 1000);
  &#125;);
&#125;);
hook.tapPromise(&quot;fn2&quot;, (arg1, arg2, arg3) &#x3D;&gt; &#123;
  return new Promise((resolve, reject) &#x3D;&gt; &#123;
    setTimeout(() &#x3D;&gt; &#123;
      console.log(&quot;fn2&quot;, arg1, arg2, arg3);
      resolve();
    &#125;, 500);
  &#125;);
&#125;);
&#x2F;&#x2F; 执行
&#x2F;&#x2F; 执行顺序则是根据这个实例类型来决定的
hook.promise(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);

&#x2F;&#x2F; 执行结果
&#x2F;&#x2F; fn2 a b c
&#x2F;&#x2F; fn0 a b c
&#x2F;&#x2F; fn1 a b c</code></pre>

<p><code>tapAsync</code> 和 <code>callAsync</code>的组合同理</p>
<p><code>promise</code> 由<a href="https://sourcegraph.com/github.com/webpack/tapable/-/blob/lib/AsyncParallelBailHook.js?L10:1">AsyncParallelBailHookCodeFactory</a>的<code>content</code>实现。 结果如下：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">&quot;use strict&quot;;
var _context;
var _x &#x3D; this._x;
var _results &#x3D; new Array(3);
var _checkDone &#x3D; function () &#123;
  for (var i &#x3D; 0; i &lt; _results.length; i++) &#123;
    var item &#x3D; _results[i];
    if (item &#x3D;&#x3D;&#x3D; undefined) return false;
    if (item.result !&#x3D;&#x3D; undefined) &#123;
      return item.result;
      return true;
    &#125;
    if (item.error) &#123;
      throw item.error;
      return true;
    &#125;
  &#125;
  return false;
&#125;;
do &#123;
  var _counter &#x3D; 3;
  var _done &#x3D; function () &#123;&#125;;
  if (_counter &lt;&#x3D; 0) break;
  var _fn0 &#x3D; _x[0];
  var _hasResult0 &#x3D; false;
  var _promise0 &#x3D; _fn0(arg1, arg2, arg3);
  &#x2F;&#x2F; 判断返回是不是promise
  if (!_promise0 || !_promise0.then)
    throw new Error(
      &quot;Tap function (tapPromise) did not return promise (returned &quot; +
        _promise0 +
        &quot;)&quot;
    );
  _promise0.then(
    function (_result0) &#123;
      _hasResult0 &#x3D; true;
      if (_counter &gt; 0) &#123;
        if (
          0 &lt; _results.length &amp;&amp;
          (_result0 !&#x3D;&#x3D; undefined &amp;&amp; (_results.length &#x3D; 1),
          (_results[0] &#x3D; &#123; result: _result0 &#125;),
          _checkDone())
        ) &#123;
          _counter &#x3D; 0;
        &#125; else &#123;
          if (--_counter &#x3D;&#x3D;&#x3D; 0) _done();
        &#125;
      &#125;
    &#125;,
    function (_err0) &#123;
      if (_hasResult0) throw _err0;
      if (_counter &gt; 0) &#123;
        if (
          0 &lt; _results.length &amp;&amp;
          ((_results.length &#x3D; 1),
          (_results[0] &#x3D; &#123; error: _err0 &#125;),
          _checkDone())
        ) &#123;
          _counter &#x3D; 0;
        &#125; else &#123;
          if (--_counter &#x3D;&#x3D;&#x3D; 0) _done();
        &#125;
      &#125;
    &#125;
  );
  if (_counter &lt;&#x3D; 0) break;
  if (1 &gt;&#x3D; _results.length) &#123;
    if (--_counter &#x3D;&#x3D;&#x3D; 0) _done();
  &#125; else &#123;
    var _fn1 &#x3D; _x[1];
    var _hasResult1 &#x3D; false;
    var _promise1 &#x3D; _fn1(arg1, arg2, arg3);
    &#x2F;&#x2F; ...
    _promise1.then(
      function (_result1) &#123;
        _hasResult1 &#x3D; true;
        if (_counter &gt; 0) &#123;
          if (
            1 &lt; _results.length &amp;&amp;
            (_result1 !&#x3D;&#x3D; undefined &amp;&amp; (_results.length &#x3D; 2),
            (_results[1] &#x3D; &#123; result: _result1 &#125;),
            _checkDone())
          ) &#123;
            _counter &#x3D; 0;
          &#125; else &#123;
            if (--_counter &#x3D;&#x3D;&#x3D; 0) _done();
          &#125;
        &#125;
      &#125;,
      function (_err1) &#123;
        if (_hasResult1) throw _err1;
        if (_counter &gt; 0) &#123;
          if (
            1 &lt; _results.length &amp;&amp;
            ((_results.length &#x3D; 2),
            (_results[1] &#x3D; &#123; error: _err1 &#125;),
            _checkDone())
          ) &#123;
            _counter &#x3D; 0;
          &#125; else &#123;
            if (--_counter &#x3D;&#x3D;&#x3D; 0) _done();
          &#125;
        &#125;
      &#125;
    );
  &#125;
  if (_counter &lt;&#x3D; 0) break;
  if (2 &gt;&#x3D; _results.length) &#123;
    if (--_counter &#x3D;&#x3D;&#x3D; 0) _done();
  &#125; else &#123;
    var _fn2 &#x3D; _x[2];
    var _hasResult2 &#x3D; false;
    var _promise2 &#x3D; _fn2(arg1, arg2, arg3);
    &#x2F;&#x2F; ...
    _promise2.then(
      function (_result2) &#123;
        _hasResult2 &#x3D; true;
        if (_counter &gt; 0) &#123;
          if (
            2 &lt; _results.length &amp;&amp;
            (_result2 !&#x3D;&#x3D; undefined &amp;&amp; (_results.length &#x3D; 3),
            (_results[2] &#x3D; &#123; result: _result2 &#125;),
            _checkDone())
          ) &#123;
            _counter &#x3D; 0;
          &#125; else &#123;
            if (--_counter &#x3D;&#x3D;&#x3D; 0) _done();
          &#125;
        &#125;
      &#125;,
      function (_err2) &#123;
        if (_hasResult2) throw _err2;
        if (_counter &gt; 0) &#123;
          if (
            2 &lt; _results.length &amp;&amp;
            ((_results.length &#x3D; 3),
            (_results[2] &#x3D; &#123; error: _err2 &#125;),
            _checkDone())
          ) &#123;
            _counter &#x3D; 0;
          &#125; else &#123;
            if (--_counter &#x3D;&#x3D;&#x3D; 0) _done();
          &#125;
        &#125;
      &#125;
    );
  &#125;
&#125; while (false);</code></pre>

<p>参考</p>
<p><a href="https://github.com/webpack/tapable">tapable</a></p>
<p><a href="https://www.cnblogs.com/dennisj/p/14606902.html">webpack 核心模块 tapable 源码解析</a></p>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
</search>
